---
title: "Moq"
description: "TODO"
tags:
  - "CSharp"
  - "Moq"
---




Today I will demonstrate an experiment I did with Moq based on a conversation I had with a colleague over at ilonx.

For this demonstration, I will use the test framework of preference, XUnit. 

There are a lot of ways to structure your test code. For example, in XUnit, there are different ways to share context between your tests (https://xunit.net/docs/shared-context).

Of course, it is a tradeoff. By separating mock code from your test, it is not instantly clear how your Mock is working. But in my opinion with all the "Verify", "Setups" and "Returns" it is not the case anyway.

Situation Sketch
Let us for a moment assume you have a system that interfaces with another system, for example, a repository pattern to interface with the database via Entity Framework. You use this repository at multiple points in your application. So when testing the code that depends on this repository, you don't want to bother with testing against the actual database, so you have two options, either write a stubbed implementation of your interface or use a framework like Moq.

Since this post is about the use of Moq, you guessed it you choose Moq to be the fake repository. 

So you end up with something like

var repoMock = new Mock<IRepo>();





https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019

https://docs.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2019

https://docs.microsoft.com/en-us/visualstudio/test/getting-started-with-unit-testing?view=vs-2019&tabs=mstest












-------









https://github.com/Moq/moq4/wiki/Quickstart

maxhamulyak@Maxs-MacBook-Pro posts % mkdir MockDemo
maxhamulyak@Maxs-MacBook-Pro posts % cd MockDemo 
maxhamulyak@Maxs-MacBook-Pro MockDemo % ls
maxhamulyak@Maxs-MacBook-Pro MockDemo % dotnet new sln
The template "Solution File" was created successfully.
maxhamulyak@Maxs-MacBook-Pro MockDemo % ls
MockDemo.sln
maxhamulyak@Maxs-MacBook-Pro MockDemo % mkdir src
maxhamulyak@Maxs-MacBook-Pro MockDemo % dotnet new classlib --framework netstandard2.1 --name DemoLib
The template "Class library" was created successfully.

Processing post-creation actions...
Running 'dotnet restore' on DemoLib/DemoLib.csproj...
  Determining projects to restore...
  Restored /Users/maxhamulyak/Downloads/Development/Blog/posts/MockDemo/DemoLib/DemoLib.csproj (in 73 ms).
Restore succeeded.

maxhamulyak@Maxs-MacBook-Pro MockDemo % ls    
DemoLib		MockDemo.sln	src
maxhamulyak@Maxs-MacBook-Pro MockDemo % rm -rf src 
maxhamulyak@Maxs-MacBook-Pro MockDemo % dotnet new xunit --framework netcoreapp3.1 --name DemoTests
The template "xUnit Test Project" was created successfully.

Processing post-creation actions...
Running 'dotnet restore' on DemoTests/DemoTests.csproj...
  Determining projects to restore...
  Restored /Users/maxhamulyak/Downloads/Development/Blog/posts/MockDemo/DemoTests/DemoTests.csproj (in 623 ms).
Restore succeeded.

maxhamulyak@Maxs-MacBook-Pro MockDemo % dotnet sln add **/*.csproj
Project `DemoLib/DemoLib.csproj` added to the solution.
Project `DemoTests/DemoTests.csproj` added to the solution.

maxhamulyak@Maxs-MacBook-Pro DemoTests % dotnet add reference ../DemoLib/DemoLib.csproj
Reference `..\DemoLib\DemoLib.csproj` added to the project.
maxhamulyak@Maxs-MacBook-Pro DemoTests % 


## Unit Test

```cs
    public class UnitTest1
    {
        [Fact]
        public async Task Test2()
        {
            var shapeAccessMock = new ShapeAccessMock();
            var sut = new ShapeManager(shapeAccessMock.Object);
            await sut.Test();

            var requests = shapeAccessMock.CreateShapeRequests.Count;
        }
    }
```

## Mock

```cs
public class ShapeAccessMock : Mock<IShapeAccess>
    {
        internal class Shape
        {
            public string Id { get;set; }
            public bool IsRemoved { get;set; }
        }

        public List<CreateShapesRequest> CreateShapeRequests { get; } = new List<CreateShapesRequest>();

        private List<Shape> _shapes = new List<Shape>();
        private int _beforeCreateIndex = 0;

        public ShapeAccessMock()
        {
            Setup(x => x.Create(It.IsAny<CreateShapesRequest>()))
                .Callback<CreateShapesRequest>(request => {
                    CreateShapeRequests.Add(request);
                    _beforeCreateIndex = _shapes.Count;
                    foreach(var x in request.CreateShapeRequests)
                    {
                        _shapes.Add(new Shape { 
                            Id = DateTime.Now.ToShortDateString()
                        });
                    }
                })
                .ReturnsAsync(() => new CreateShapesResponse {
                    Shapes = _shapes.Skip(_beforeCreateIndex)
                                    //.Where(x => !x.IsRemoved)
                                    .Select(x => new DemoLib.Shape {
                                        Id = x.Id
                                    })
                                    .ToArray()
                });

            Setup(x => x.Retrieve(It.IsAny<RetrieveShapesCriteria>()))
                .ReturnsAsync(() => {
                    var result = new RetrieveShapesResponse
                    {
                        Shapes = _shapes.Where(x => !x.IsRemoved).Select(x => new DemoLib.Shape
                        {
                            Id = x.Id
                        }).ToArray()
                    };
                    return result;
                });

            Setup(x => x.Delete(It.IsAny<RemoveShapesRequest>()))
                .Callback<RemoveShapesRequest>(request => {
                    foreach(var x in request.RemoveShapeRequests)
                    {
                        var existing = _shapes.SingleOrDefault(y => y.Id.Equals(x.Id));
                        if (existing != null)
                        {
                            existing.IsRemoved = true;
                        }
                    }
                });        
        }
    }
```

## System

```cs
using System.Threading.Tasks;

namespace DemoLib
{

    public class ShapeManager
    {
        private readonly IShapeAccess _shapeAccess;
        public ShapeManager(IShapeAccess shapeAccess)
        {
            _shapeAccess = shapeAccess;
        }

        public async Task Test()
        {
            var demo = new CreateShapeRequest { Name = "DemoTime" };
            
            var createResponse = await _shapeAccess.Create(new CreateShapesRequest { CreateShapeRequests = new CreateShapeRequest[] { 
                demo
            }});

            var readResponse = await _shapeAccess.Retrieve(new RetrieveShapesCriteria { ShapeIds = new string[] { createResponse.Shapes[0].Id } });

            await _shapeAccess.Delete(new RemoveShapesRequest { RemoveShapeRequests = new RemoveShapeRequest[] {
                new RemoveShapeRequest { Id = readResponse.Shapes[0].Id }
            }});

            var readAfterDelete = await _shapeAccess.Retrieve(new RetrieveShapesCriteria { ShapeIds = new string[] { createResponse.Shapes[0].Id } });
        }
    }

    public interface IShapeAccess
    {
        Task Delete(RemoveShapesRequest request);
        Task<RetrieveShapesResponse> Retrieve(RetrieveShapesCriteria criteria = null);
        Task<CreateShapesResponse> Create(CreateShapesRequest request);
    }


    public class Shape
    {
        public string Id { get;set; }

        public string Name { get;set; }
    }

    public class RemoveShapeRequest
    { 
        public string Id { get; set; }
    }
    public class RemoveShapesRequest
    {
        public RemoveShapeRequest[] RemoveShapeRequests { get;set; }
    }

    public class RetrieveShapesCriteria
    {
        public string[] ShapeIds { get;set; }
    }

    public class RetrieveShapesResponse
    {
        public Shape[] Shapes { get;set; }
    }

    public class CreateShapesResponse
    {
        public Shape[] Shapes { get;set; }
    }

    public class CreateShapesRequest
    { 
        public CreateShapeRequest[] CreateShapeRequests { get;set; }
    }

    public class CreateShapeRequest
    {
        public string Name { get;set; }
    }
}
```