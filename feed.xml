<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <id>https://kaylumah.nl/feed.xml</id>
    <updated>2021-05-23T22:08:29.4539368+00:00</updated>
    <link href="https://kaylumah.nl/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://kaylumah.nl" rel="alternate" type="text/html" />
    <title>Kaylumah, Max Hamuly&#225;k | Portfolio &amp; Blog</title>
    <subtitle>A blog and portfolio website for Kaylumah, a company founded by Max Hamulyák</subtitle>
    <icon>https://kaylumah.nl/assets/logo_small.svg</icon>
    <logo>https://kaylumah.nl/assets/logo.svg</logo>
    <rights>© Kaylumah. All rights reserved.</rights>
    <generator uri="/feed.xml" version="8a2b46b">Kaylumah Site Generator</generator>
    <entry>
        <id>https://kaylumah.nl/2021/05/23/generate-csharp-client-for-openapi.html</id>
        <title>Generate C# client for OpenAPI</title>
        <author>
            <name>Max Hamulyák</name>
            <email>max@kaylumah.nl</email>
            <uri>https:/kaylumah.nl</uri>
        </author>
        <published>2021-05-23T00:00:00.0000000+00:00</published>
        <updated>2021-05-23T00:00:00.0000000+00:00</updated>
        <link href="https://kaylumah.nl/2021/05/23/generate-csharp-client-for-openapi.html" />
        <content type="html">
            &lt;p&gt;I&#39;ve recently worked on a project where I was the consumer of a third party API. Luckily for me, we decided on an Open API specification which made integrating services a breeze. If you have been following my content, you know I often use C# in my projects. So I needed a type-safe client for use in my C# code base.&lt;/p&gt;
&lt;p&gt;To accomplish my goals, I used the &lt;a href=&quot;https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild&quot; class=&quot;external&quot;&gt;NSwag library&lt;/a&gt; created by Rico Suter. This project provides me with an MSBuild task for generating clients. In my case, I used a JSON file version to generate my client. NSwag is not limited to just one way of working.&lt;/p&gt;
&lt;h2 id=&quot;what-is-openapi&quot;&gt;&lt;a href=&quot;#what-is-openapi&quot;&gt;What is OpenAPI&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First, a quick recap of what is an OpenAPI. According to the &lt;a href=&quot;https://swagger.io/specification/&quot; class=&quot;external&quot;&gt;official definition&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.&lt;/p&gt;
&lt;p&gt;An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That&#39;s pretty cool. Also, if you are wondering about the difference between OpenAPI / Swagger, Swagger is part of the OpenAPI initiative since 2015. But in short OpenAPI = specification, Swagger = Tooling. In this article, I am not going into much detail in setting up your API, but Microsoft &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-5.0#openapi-vs-swagger&quot; class=&quot;external&quot;&gt;described&lt;/a&gt; three versions on how to combine it with .NET Core.&lt;/p&gt;
&lt;h2 id=&quot;generate-client-from-file&quot;&gt;&lt;a href=&quot;#generate-client-from-file&quot;&gt;Generate client from file&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first version uses a file to generate our code. In our case, we will use a &lt;a href=&quot;https://petstore.swagger.io/v2/swagger.json&quot; class=&quot;external&quot;&gt;JSON file&lt;/a&gt; from the &lt;a href=&quot;https://petstore.swagger.io/&quot; class=&quot;external&quot;&gt;PetStore&lt;/a&gt; example project as provided by the swagger team.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;dotnet new classlib --framework netstandard2.0 --output src/Sdks/PetStore --name Kaylumah.GenerateCSharpClientForOpenAPI.Sdks.PetStore
dotnet add package NSwag.MSBuild
dotnet add package System.ComponentModel.Annotations
dotnet add package Newtonsoft.Json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Safe the pet store OpenAPI JSON in the project we just created under the name &lt;code&gt;swagger.json&lt;/code&gt;. We also need a &lt;code&gt;nswag.json&lt;/code&gt; file with the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &amp;quot;runtime&amp;quot;: &amp;quot;NetCore31&amp;quot;,
    &amp;quot;documentGenerator&amp;quot;: {
        &amp;quot;fromDocument&amp;quot;: {
            &amp;quot;json&amp;quot;: &amp;quot;swagger.json&amp;quot;
        }
    },
    &amp;quot;codeGenerators&amp;quot;: {
        &amp;quot;openApiToCSharpClient&amp;quot;: {
            &amp;quot;output&amp;quot;: &amp;quot;Client.g.cs&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use an MSBuild task that calls NSwag. Update &lt;code&gt;Kaylumah.GenerateCSharpClientForOpenAPI.Sdks.PetStore.csproj&lt;/code&gt; to look like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Newtonsoft.Json&amp;quot; Version=&amp;quot;13.0.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;NSwag.MSBuild&amp;quot; Version=&amp;quot;13.11.1&amp;quot;&amp;gt;
      &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
      &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;System.ComponentModel.Annotations&amp;quot; Version=&amp;quot;5.0.0&amp;quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &amp;lt;Target Name=&amp;quot;GenerateSdk&amp;quot; BeforeTargets=&amp;quot;Build&amp;quot;&amp;gt;
    &amp;lt;Exec Command=&amp;quot;$(NSwagExe_Core31) run nswag.json &amp;quot; /&amp;gt;
  &amp;lt;/Target&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After building the project, we have a file named &lt;code&gt;Client.g.cs&lt;/code&gt; containing everything we need to consume the PetStore API. We can use a console application to verify that we can make API calls.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;dotnet new console --framework netcoreapp3.1 --output src/Client/ApiClient --name Kaylumah.GenerateCSharpClientForOpenAPI.Client.ApiClient
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An example call we can make with our API looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Net.Http;
using System.Threading.Tasks;

namespace Kaylumah.GenerateCSharpClientForOpenAPI.Client.ApiClient
{
    class Program
    {
        static async Task Main(string[] args)
        {
            var httpClient = new HttpClient();
            var apiClient = new MyNamespace.Client(httpClient);
            var result = await apiClient.GetInventoryAsync();
            Console.WriteLine(string.Join(&amp;quot;|&amp;quot;, result.Keys));
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;influence-created-output&quot;&gt;&lt;a href=&quot;#influence-created-output&quot;&gt;Influence created output&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We have established that we have a working C# client for the PetStore API. Let us look at the generated result. We got DTO&#39;s for every definition in the definitions part of the specification. We also got a class named &lt;code&gt;Client&lt;/code&gt; with methods as &lt;code&gt;GetInventoryAsync&lt;/code&gt;. All the generated code in &lt;code&gt;Client.g.cs&lt;/code&gt; is part of the namespace &lt;code&gt;MyNamespace&lt;/code&gt;; this is not helpful if I wanted to create a project with many API clients.&lt;/p&gt;
&lt;p&gt;Two things influence the generated code. First, how you specify your fields has the most influence. For example, are your fields required, are they nullable and which kind of values are allowed. You cannot always influence this as sometimes you consume an external API; such is the case with our PetStore implementation. Luckily we can control the output by tuning values in our NSwag configuration. An eagle-eyed reader will have noticed that we are already doing this. Our nswag.json is responsible for the result. In this case, we are using the &lt;code&gt;output&lt;/code&gt; variable to control the generated file&#39;s name.&lt;/p&gt;
&lt;p&gt;We control the output by using an NSwag configuration document usually called &lt;code&gt;*.nswag&lt;/code&gt; or &lt;code&gt;nswag.json&lt;/code&gt;. It can be generated via NSwagStudio or manually. Over at the &lt;a href=&quot;https://github.com/RicoSuter/NSwag/wiki/NSwag-Configuration-Document&quot; class=&quot;external&quot;&gt;NSwag Wiki&lt;/a&gt; you can read all about it. It&#39;s outside of the scope of this article to go into all options, so I will demonstrate a couple of changes I like to make in my projects.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: You can generate a nswag configuration file by running &lt;code&gt;&amp;lt;Exec Command=&amp;quot;$(NSwagExe_Core31) new&amp;quot; /&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I encourage you to take a look at the documentation to see all configuration options. Some options apply to every generator, and some only to C# clients. See the table below for links to every section. Every section describes the options and default values if applicable.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Settings&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/RicoSuter/NSwag/wiki/ClientGeneratorBaseSettings&quot; class=&quot;external&quot;&gt;ClientGeneratorBaseSettings&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Common settings for all client code generators.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/RicoSuter/NSwag/wiki/CSharpGeneratorBaseSettings&quot; class=&quot;external&quot;&gt;CSharpGeneratorBaseSettings&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Base settings for all C# code generators.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/RicoSuter/NSwag/wiki/CSharpClientGeneratorSettings&quot; class=&quot;external&quot;&gt;CSharpClientGeneratorSettings&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Settings for C# clients.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If you look closely at your build log, you see the following line &lt;code&gt;Executing file &#39;nswag.json&#39; with variables &#39;&#39;...&lt;/code&gt;. So how do we pass variables to NSwag? Update the statement to &lt;code&gt;$(NSwagExe_Core31) run nswag.json /variables:Configuration=$(Configuration)&lt;/code&gt; . Here we define a variable named Configuration and assign it the MSBuild value for $(Configuration). If we build our project, the logline reads &lt;code&gt;Executing file &#39;nswag.json&#39; with variables &#39;Configuration=Debug&#39;...&lt;/code&gt;. You also have the option to supply default values in your NSwag configuration. This way, you don&#39;t see it as part of your build log, but it helps omit parts from the command.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Property&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;namespace&lt;/code&gt; and &lt;code&gt;contractsNamespace&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Control the namespace of the generated code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;generateContractsOutput&lt;/code&gt; and &lt;code&gt;contractsOutputFilePath&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Control seperation of contract and implementation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;generateClientInterfaces&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;create an interface&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;exceptionClass&lt;/code&gt; and &lt;code&gt;className&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;control classnames&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operationGenerationMode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;how to create client for multiple endpoints&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;After our modifications, our NSwag file looks like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &amp;quot;runtime&amp;quot;: &amp;quot;NetCore31&amp;quot;,
    &amp;quot;defaultVariables&amp;quot;: &amp;quot;Configuration=Debug&amp;quot;,
    &amp;quot;documentGenerator&amp;quot;: {
        &amp;quot;fromDocument&amp;quot;: {
            &amp;quot;json&amp;quot;: &amp;quot;$(InputDocument)&amp;quot;
        }
    },
    &amp;quot;codeGenerators&amp;quot;: {
        &amp;quot;openApiToCSharpClient&amp;quot;: {
            &amp;quot;generateClientInterfaces&amp;quot;: true,
            &amp;quot;exceptionClass&amp;quot;: &amp;quot;$(SdkName)ApiException&amp;quot;,
            &amp;quot;useBaseUrl&amp;quot;: true,
            &amp;quot;generateBaseUrlProperty&amp;quot;: true,
            &amp;quot;generateContractsOutput&amp;quot;: true,
            &amp;quot;contractsNamespace&amp;quot;: &amp;quot;$(SdkNamespace).Interface&amp;quot;,
            &amp;quot;contractsOutputFilePath&amp;quot;: &amp;quot;$(GeneratedContractFile)&amp;quot;,
            &amp;quot;className&amp;quot;: &amp;quot;$(SdkName)Client&amp;quot;,
            &amp;quot;operationGenerationMode&amp;quot;: &amp;quot;SingleClientFromOperationId&amp;quot;,
            &amp;quot;namespace&amp;quot;: &amp;quot;$(SdkNamespace).Service&amp;quot;,
            &amp;quot;output&amp;quot;: &amp;quot;$(GeneratedClientFile)&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To pass all the values to NSwag, we update our csproj file to look like this. For demonstration purposes, I show that the name of the MSBuild variable does not need to match the NSwag variable. Do take care that the variable names passed to NSwag need to match the name in nswag.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Newtonsoft.Json&amp;quot; Version=&amp;quot;13.0.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;NSwag.MSBuild&amp;quot; Version=&amp;quot;13.11.1&amp;quot;&amp;gt;
      &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
      &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;System.ComponentModel.Annotations&amp;quot; Version=&amp;quot;5.0.0&amp;quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &amp;lt;Target Name=&amp;quot;GenerateSdk&amp;quot; BeforeTargets=&amp;quot;Build&amp;quot;&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;OpenAPIDocument&amp;gt;swagger.json&amp;lt;/OpenAPIDocument&amp;gt;
        &amp;lt;NSwagConfiguration&amp;gt;nswag.json&amp;lt;/NSwagConfiguration&amp;gt;

        &amp;lt;SdkNamespace&amp;gt;$(RootNamespace)&amp;lt;/SdkNamespace&amp;gt;
        &amp;lt;SdkName&amp;gt;PetStore&amp;lt;/SdkName&amp;gt;
        &amp;lt;GeneratedInterfaceFile&amp;gt;$(SdkName).Interface.g.cs&amp;lt;/GeneratedInterfaceFile&amp;gt;
        &amp;lt;GeneratedServiceFile&amp;gt;$(SdkName).Service.g.cs&amp;lt;/GeneratedServiceFile&amp;gt;

    &amp;lt;/PropertyGroup&amp;gt;
    &amp;lt;Error Text=&amp;quot;The OpenAPI document &#39;$(OpenAPIDocument)&#39; does not exists!&amp;quot; Condition=&amp;quot;!Exists(&#39;$(OpenAPIDocument)&#39;)&amp;quot; /&amp;gt;
    &amp;lt;Error Text=&amp;quot;The NSwag configuration &#39;$(NSwagConfiguration)&#39; does not exists!&amp;quot; Condition=&amp;quot;!Exists(&#39;$(NSwagConfiguration)&#39;)&amp;quot; /&amp;gt;
    &amp;lt;Exec Command=&amp;quot;$(NSwagExe_Core31) run $(NSwagConfiguration) /variables:Configuration=$(Configuration),InputDocument=$(OpenAPIDocument),SdkName=$(SdkName),SdkNamespace=$(SdkNamespace),GeneratedClientFile=$(GeneratedServiceFile),GeneratedContractFile=$(GeneratedInterfaceFile)&amp;quot; /&amp;gt;
  &amp;lt;/Target&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;generate-client-from-api-in-your-project&quot;&gt;&lt;a href=&quot;#generate-client-from-api-in-your-project&quot;&gt;Generate client from API in your project&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Our second version generates the SDK based on a .NET Core API project in our solution, which can be very useful if you want to provide the client in a NuGet package to other projects/teams in your organization. The project setup will be almost identical to our file-based setup.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;dotnet new classlib --framework netstandard2.0 --output src/Sdks/FromNswagApi --name Kaylumah.GenerateCSharpClientForOpenAPI.Sdks.FromNswagApi
dotnet add package NSwag.MSBuild
dotnet add package System.ComponentModel.Annotations
dotnet add package Newtonsoft.Json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we are going to create an SDK we first need to generate our API project. We generate a webapi with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;dotnet new webapi --framework netcoreapp3.1 --output src/Apis/Nswag/WeatherForecastApi --name Kaylumah.GenerateCSharpClientForOpenAPI.Apis.Nswag.WeatherForecastApi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that I am specifying the optional --framework option for creating the projects; this has two reasons. First, I prefer to use LTS versions of the Microsoft SDK and secondly, Microsoft made &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-5.0?view=aspnetcore-5.0#openapi-specification-on-by-default&quot; class=&quot;external&quot;&gt;changes&lt;/a&gt; to the webapi template in the NET5 SDK that makes it opt-out to use OpenAPI and defaults to Swashbuckle, which I don&#39;t want in this case.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &amp;quot;runtime&amp;quot;: &amp;quot;NetCore31&amp;quot;,
    &amp;quot;documentGenerator&amp;quot;: {
        &amp;quot;aspNetCoreToOpenApi&amp;quot;: {
            &amp;quot;project&amp;quot;: &amp;quot;../../Apis/Nswag/WeatherForecastApi/Kaylumah.GenerateCSharpClientForOpenAPI.Apis.Nswag.WeatherForecastApi.csproj&amp;quot;
        }
    },
    &amp;quot;codeGenerators&amp;quot;: {
        &amp;quot;openApiToCSharpClient&amp;quot;: {
            &amp;quot;generateClientInterfaces&amp;quot;: true,
            &amp;quot;exceptionClass&amp;quot;: &amp;quot;$(SdkName)ApiException&amp;quot;,
            &amp;quot;useBaseUrl&amp;quot;: true,
            &amp;quot;generateBaseUrlProperty&amp;quot;: true,
            &amp;quot;generateContractsOutput&amp;quot;: true,
            &amp;quot;contractsNamespace&amp;quot;: &amp;quot;$(SdkNamespace).Interface&amp;quot;,
            &amp;quot;contractsOutputFilePath&amp;quot;: &amp;quot;$(GeneratedContractFile)&amp;quot;,
            &amp;quot;className&amp;quot;: &amp;quot;$(SdkName)Client&amp;quot;,
            &amp;quot;operationGenerationMode&amp;quot;: &amp;quot;SingleClientFromOperationId&amp;quot;,
            &amp;quot;namespace&amp;quot;: &amp;quot;$(SdkNamespace).Service&amp;quot;,
            &amp;quot;output&amp;quot;: &amp;quot;$(GeneratedClientFile)&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like before, we need a &lt;code&gt;GenerateSdk&lt;/code&gt; target; the difference is that we don&#39;t have a &lt;code&gt;swagger.json&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Target Name=&amp;quot;GenerateSdk&amp;quot; BeforeTargets=&amp;quot;Build&amp;quot;&amp;gt;
&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;NSwagConfiguration&amp;gt;nswag.json&amp;lt;/NSwagConfiguration&amp;gt;

    &amp;lt;SdkNamespace&amp;gt;$(RootNamespace)&amp;lt;/SdkNamespace&amp;gt;
    &amp;lt;SdkName&amp;gt;Weather&amp;lt;/SdkName&amp;gt;
    &amp;lt;GeneratedInterfaceFile&amp;gt;$(SdkName).Interface.g.cs&amp;lt;/GeneratedInterfaceFile&amp;gt;
    &amp;lt;GeneratedServiceFile&amp;gt;$(SdkName).Service.g.cs&amp;lt;/GeneratedServiceFile&amp;gt;

&amp;lt;/PropertyGroup&amp;gt;
&amp;lt;Error Text=&amp;quot;The NSwag configuration &#39;$(NSwagConfiguration)&#39; does not exists!&amp;quot; Condition=&amp;quot;!Exists(&#39;$(NSwagConfiguration)&#39;)&amp;quot; /&amp;gt;
&amp;lt;Exec Command=&amp;quot;$(NSwagExe_Core31) run $(NSwagConfiguration) /variables:Configuration=$(Configuration),SdkName=$(SdkName),SdkNamespace=$(SdkNamespace),GeneratedClientFile=$(GeneratedServiceFile),GeneratedContractFile=$(GeneratedInterfaceFile)&amp;quot; /&amp;gt;
&amp;lt;/Target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we try to build our project now, we get an error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-output&quot;&gt;Microsoft (R) Build Engine version 16.9.0+57a23d249 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  All projects are up-to-date for restore.
  NSwag command line tool for .NET Core NetCore31, toolchain v13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v12.0.0.0))
  Visit http://NSwag.org for more information.
  NSwag bin directory: /Users/maxhamulyak/.nuget/packages/nswag.msbuild/13.11.1/tools/NetCore31
  
  Executing file &#39;nswag.json&#39; with variables &#39;Configuration=Debug&#39;...
  Launcher directory: /Users/maxhamulyak/.nuget/packages/nswag.msbuild/13.11.1/tools/NetCore31
  System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.
   ---&amp;gt; System.InvalidOperationException: No service for type &#39;NSwag.Generation.IOpenApiDocumentGenerator&#39; has been registered.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason behind this error is that the tool requires NSwag in the API project. To do this, we need to install the NSwag.AspNetCore package with &lt;code&gt;dotnet add package NSwag.AspNetCore&lt;/code&gt;.  The scope of this tutorial is not how to set up an API project with NSwag luckily, the &lt;a href=&quot;https://github.com/RicoSuter/NSwag#usage-in-c&quot; class=&quot;external&quot;&gt;guide&lt;/a&gt; is straightforward. We modify the &lt;code&gt;ConfigureServices&lt;/code&gt; method in Startup.cs with &lt;code&gt;services.AddOpenApiDocument();&lt;/code&gt; and we add &lt;code&gt;app.UseOpenApi();&lt;/code&gt; and &lt;code&gt;app.UseSwaggerUi3();&lt;/code&gt; to the &lt;code&gt;Configure&lt;/code&gt; method. We have an Open API specification for our WeatherForecast controller with these changes and can easily view and test it with Swagger UI.&lt;/p&gt;
&lt;p&gt;Now we can successfully generate a client for the WeatherForecastAPI!&lt;/p&gt;
&lt;h2 id=&quot;generate-client-from-swashbuckle-project&quot;&gt;&lt;a href=&quot;#generate-client-from-swashbuckle-project&quot;&gt;Generate client from Swashbuckle project&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The third and final version I will look at is a combination of both previous versions. I already hinted at it in the last section, but Microsoft made some &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-5.0?view=aspnetcore-5.0#openapi-specification-on-by-default&quot; class=&quot;external&quot;&gt;changes&lt;/a&gt; to the template to generate them by default using Swashbuckle.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;dotnet new classlib --framework netstandard2.0 --output src/Sdks/FromSwashbuckleApi --name Kaylumah.GenerateCSharpClientForOpenAPI.Sdks.FromSwashbuckleApi
dotnet add package NSwag.MSBuild
dotnet add package System.ComponentModel.Annotations
dotnet add package Newtonsoft.Json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like before, we also need a webapi project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;dotnet new webapi --framework netcoreapp3.1 --output src/Apis/Swashbuckle/WeatherForecastApi --name Kaylumah.GenerateCSharpClientForOpenAPI.Apis.Swashbuckle.WeatherForecastApi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, we could launch the API project and browse to &lt;code&gt;https://localhost:5001/swagger/index.html&lt;/code&gt; and download the specification from there. But I will opt for automating the process with a &lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore#swashbuckleaspnetcorecli&quot; class=&quot;external&quot;&gt;CLI&lt;/a&gt; provided as a dotnet tool by Swashbuckle.&lt;/p&gt;
&lt;p&gt;Since we are using netcoreapp3.1 we can make use of a local tool manifest.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;dotnet new tool-manifest
dotnet tool install --version 6.1.4 Swashbuckle.AspNetCore.Cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This allows us to run &lt;code&gt;swagger tofile --output [output] [startupassembly] [swaggerdoc]&lt;/code&gt;. For example, in the FromSwashbuckleApi folder we would run &lt;code&gt;dotnet swagger tofile --output swagger.json ../../Apis/Swashbuckle/WeatherForecastApi/bin/Debug/netcoreapp3.1/Kaylumah.GenerateCSharpClientForOpenAPI.Apis.Swashbuckle.WeatherForecastApi.dll v1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At the moment, this returns an error if you target a netcoreapp3.1 project when using a net5 SDK. This &lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/issues/2006&quot; class=&quot;external&quot;&gt;issue&lt;/a&gt; describes a change in 6.x of the tool. A workaround for this is using a global.json file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &amp;quot;sdk&amp;quot;: {
        &amp;quot;version&amp;quot;: &amp;quot;3.1.406&amp;quot;,
        &amp;quot;rollForward&amp;quot;: &amp;quot;latestPatch&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similar to the NSwag version, we still need to add Swashbuckle to the webapi. Luckily just as with NSwag the &lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore#getting-started&quot; class=&quot;external&quot;&gt;guide&lt;/a&gt; is straightforward.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Target Name=&amp;quot;GenerateOpenAPI&amp;quot; BeforeTargets=&amp;quot;GenerateSdk&amp;quot;&amp;gt;
  &amp;lt;Exec Command=&amp;quot;dotnet swagger tofile --output swagger.json ../../Apis/Swashbuckle/WeatherForecastApi/bin/Debug/netcoreapp3.1/Kaylumah.GenerateCSharpClientForOpenAPI.Apis.Swashbuckle.WeatherForecastApi.dll v1&amp;quot; /&amp;gt;
&amp;lt;/Target&amp;gt;

&amp;lt;Target Name=&amp;quot;GenerateSdk&amp;quot; BeforeTargets=&amp;quot;Build&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OpenAPIDocument&amp;gt;swagger.json&amp;lt;/OpenAPIDocument&amp;gt;
    &amp;lt;NSwagConfiguration&amp;gt;nswag.json&amp;lt;/NSwagConfiguration&amp;gt;

    &amp;lt;SdkNamespace&amp;gt;$(RootNamespace)&amp;lt;/SdkNamespace&amp;gt;
    &amp;lt;SdkName&amp;gt;Weather&amp;lt;/SdkName&amp;gt;
    &amp;lt;GeneratedInterfaceFile&amp;gt;$(SdkName).Interface.g.cs&amp;lt;/GeneratedInterfaceFile&amp;gt;
    &amp;lt;GeneratedServiceFile&amp;gt;$(SdkName).Service.g.cs&amp;lt;/GeneratedServiceFile&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;Error Text=&amp;quot;The OpenAPI document &#39;$(OpenAPIDocument)&#39; does not exists!&amp;quot; Condition=&amp;quot;!Exists(&#39;$(OpenAPIDocument)&#39;)&amp;quot; /&amp;gt;
  &amp;lt;Error Text=&amp;quot;The NSwag configuration &#39;$(NSwagConfiguration)&#39; does not exists!&amp;quot; Condition=&amp;quot;!Exists(&#39;$(NSwagConfiguration)&#39;)&amp;quot; /&amp;gt;
  &amp;lt;Exec Command=&amp;quot;$(NSwagExe_Core31) run $(NSwagConfiguration) /variables:Configuration=$(Configuration),InputDocument=$(OpenAPIDocument),SdkName=$(SdkName),SdkNamespace=$(SdkNamespace),GeneratedClientFile=$(GeneratedServiceFile),GeneratedContractFile=$(GeneratedInterfaceFile)&amp;quot; /&amp;gt;
&amp;lt;/Target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we generated a second version of our Weather API, let&#39;s quickly compare the two.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Swashbuckle
[System.CodeDom.Compiler.GeneratedCode(&amp;quot;NSwag&amp;quot;, &amp;quot;13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v12.0.0.0))&amp;quot;)]
public partial interface IWeatherClient
{
    /// &amp;lt;returns&amp;gt;Success&amp;lt;/returns&amp;gt;
    /// &amp;lt;exception cref=&amp;quot;WeatherApiException&amp;quot;&amp;gt;A server side error occurred.&amp;lt;/exception&amp;gt;
    System.Threading.Tasks.Task&amp;lt;System.Collections.Generic.ICollection&amp;lt;WeatherForecast&amp;gt;&amp;gt; WeatherForecastAsync();

    /// &amp;lt;param name=&amp;quot;cancellationToken&amp;quot;&amp;gt;A cancellation token that can be used by other objects or threads to receive notice of cancellation.&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;Success&amp;lt;/returns&amp;gt;
    /// &amp;lt;exception cref=&amp;quot;WeatherApiException&amp;quot;&amp;gt;A server side error occurred.&amp;lt;/exception&amp;gt;
    System.Threading.Tasks.Task&amp;lt;System.Collections.Generic.ICollection&amp;lt;WeatherForecast&amp;gt;&amp;gt; WeatherForecastAsync(System.Threading.CancellationToken cancellationToken);

}

// NSwag
[System.CodeDom.Compiler.GeneratedCode(&amp;quot;NSwag&amp;quot;, &amp;quot;13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v12.0.0.0))&amp;quot;)]
public partial interface IWeatherClient
{
    /// &amp;lt;exception cref=&amp;quot;WeatherApiException&amp;quot;&amp;gt;A server side error occurred.&amp;lt;/exception&amp;gt;
    System.Threading.Tasks.Task&amp;lt;System.Collections.Generic.ICollection&amp;lt;WeatherForecast&amp;gt;&amp;gt; WeatherForecast_GetAsync();

    /// &amp;lt;param name=&amp;quot;cancellationToken&amp;quot;&amp;gt;A cancellation token that can be used by other objects or threads to receive notice of cancellation.&amp;lt;/param&amp;gt;
    /// &amp;lt;exception cref=&amp;quot;WeatherApiException&amp;quot;&amp;gt;A server side error occurred.&amp;lt;/exception&amp;gt;
    System.Threading.Tasks.Task&amp;lt;System.Collections.Generic.ICollection&amp;lt;WeatherForecast&amp;gt;&amp;gt; WeatherForecast_GetAsync(System.Threading.CancellationToken cancellationToken);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Funnily enough, even in a specification as small as these, there can already be differences!&lt;/p&gt;
&lt;h2 id=&quot;closing-thoughts&quot;&gt;&lt;a href=&quot;#closing-thoughts&quot;&gt;Closing Thoughts&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As we have seen, there are multiple ways to generate a client by using &lt;code&gt;NSwag.MSBuild&lt;/code&gt;.
If I am writing an OpenAPI specification, I prefer the syntax of Swashbuckle for several things like API versioning. That, of course, is a personal preference, but since Microsoft now also offers Swashbuckle as a default, it is nice to know we can make Swashbuckle and NSwag play nice together. How I configure my API with OpenAPI, API Versioning, ProblemDetails will be part of a future blog post.&lt;/p&gt;
&lt;p&gt;So, where do we go from here? I did not mention it in the article, but in every generated client, we need to inject &lt;code&gt;System.Net.HttpClient&lt;/code&gt;, which means we can combine it with &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests&quot; class=&quot;external&quot;&gt;HttpClientFactory&lt;/a&gt; and all the options it provides. Alas, that is also a topic for another day.&lt;/p&gt;
&lt;p&gt;As always, if you have any questions, feel free to reach out. Do you have suggestions or alternatives? I would love to hear about them.&lt;/p&gt;
&lt;p&gt;The corresponding source code for this article is on &lt;a href=&quot;https://github.com/kaylumah/GenerateCSharpClientForOpenAPI&quot; class=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See you next time, stay healthy and happy coding to all &#129528;!&lt;/p&gt;
&lt;h2 id=&quot;sources&quot;&gt;&lt;a href=&quot;#sources&quot;&gt;Sources&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/RicoSuter/NSwag/wiki/&quot; class=&quot;external&quot;&gt;NSwag GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; class=&quot;external&quot;&gt;Swashbuckle GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
        </content>
        
        <summary>A look at using OpenAPI clients in C#</summary>
        
        
        <category term="CSharp" />
        
        <category term="OpenAPI" />
        
        <category term="NSwag" />
        
        <category term="Swashbuckle" />
        
        
        
            
                
            

            <media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kaylumah.nl/assets/images/posts/20210523/generate-csharp-client-for-openapi/cover_image.png" />
            <media:content medium="image" url="https://kaylumah.nl/assets/images/posts/20210523/generate-csharp-client-for-openapi/cover_image.png" xmlns:media="http://search.yahoo.com/mrss/" />

        
    </entry>
    
    <entry>
        <id>https://kaylumah.nl/2021/04/11/an-approach-to-writing-mocks.html</id>
        <title>Experiment with Moq, an approach to writing mocks</title>
        <author>
            <name>Max Hamulyák</name>
            <email>max@kaylumah.nl</email>
            <uri>https:/kaylumah.nl</uri>
        </author>
        <published>2021-04-11T00:00:00.0000000+00:00</published>
        <updated>2021-04-11T00:00:00.0000000+00:00</updated>
        <link href="https://kaylumah.nl/2021/04/11/an-approach-to-writing-mocks.html" />
        <content type="html">
            &lt;p&gt;Recently I was looking into a new way to use mocks in my unit tests. My framework of choice to write unit tests is XUnit, whereas I use Moq to create Mocks. The theory behind Moq will still apply if you use a different testing framework, and perhaps some of the things I will demonstrate will be possible in other mocking frameworks.&lt;/p&gt;
&lt;p&gt;In many projects, I find that we look at essential things like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How should the architecture look?&lt;/li&gt;
&lt;li&gt;Which design patterns should we use?&lt;/li&gt;
&lt;li&gt;Making sure we follow the SOLID principles.&lt;/li&gt;
&lt;li&gt;How should we structure our code base?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At the same time, I find that we do not give our tests the same amount of love.&lt;/p&gt;
&lt;p&gt;Wouter Roos, a colleague of mine over at ilionx, gave me this idea, and after experimenting a bit with it, I like it so much that I decided to blog about it. I tried hard to find other articles about it but did not find a post doing something similar. It wanted to make sure that the idea would also transfer to other aspects like how to mock &lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt;, that I stumbled upon &lt;a href=&quot;https://adamstorr.azurewebsites.net/blog/mocking-ilogger-with-moq&quot; class=&quot;external&quot;&gt;an excellent article&lt;/a&gt; by Adam Storr. Coincidentally Adam &lt;a href=&quot;https://exceptionnotfound.net/using-moq-to-create-fluent-test-classes-in-asp-net-core/&quot; class=&quot;external&quot;&gt;linked&lt;/a&gt; to a part in a series by Matthew Jones about Fluent Mocks. I have been reading articles written by  Matthew for some time now but missed this one. Matthews approach and, for that matter, Adam&#39;s proposal on testing ILogger are not quite the same as what I will propose, but I think these ideas will complement each other nicely. Funnily enough, I have had Adam&#39;s idea to create extensions methods on &lt;code&gt;Mock&amp;lt;T&amp;gt;&lt;/code&gt; before when setting up a mock filesystem for use in unit tests. However, I can extend on that premise with what I learned from Wouter and make it even better.&lt;/p&gt;
&lt;h2 id=&quot;system-setup&quot;&gt;&lt;a href=&quot;#system-setup&quot;&gt;System Setup&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Bear with me for a little while whilst we set up our demo scenario. In our architecture, we have defined three components. We have two resource access components and one manager. The manager is used to orchestrate our business code, and the resource access components interact with a resource, for example, a database.&lt;/p&gt;
&lt;!-- 
@startuml
title Architecture Component Diagram

component [Site\nManager] as Site
component [Article\nAccess] as Article
component [Author\nAccess] as Author


Site - -&gt; Article
Site - -&gt; Author
@enduml
 --&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210411/approach-to-writing-mocks/architecture.png&quot; alt=&quot;Architecture&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Since I am writing this blog post, what better example than a use case for a blogging platform. Imagine a platform where users can create and share their content. But you can only successfully start posts after you verified your account. In a sequence diagram, it might look something like this.&lt;/p&gt;
&lt;!-- 
@startuml
title UC: Create Article
autonumber &quot;&lt;b&gt;[000]&quot;

SiteManager -&gt; AuthorAccess: RetrieveAuthors
AuthorAccess - -&gt; SiteManager: RetrieveAuthorsResponse
SiteManager -&gt; SiteManager: is valid author?

SiteManager -&gt; ArticleAccess: CreateArticle
ArticleAccess - -&gt; SiteManager: CreateArticleResponse
@enduml
 --&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210411/approach-to-writing-mocks/sequence.png&quot; alt=&quot;Sequence&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I am going to use the dotnet CLI to create my project structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;dotnet new sln
dotnet new classlib --name Kaylumah.AdventuresWithMock.Access.Article.Interface --output src/Components/Access/Article/Interface --framework netstandard2.1
dotnet new classlib --name Kaylumah.AdventuresWithMock.Access.Article.Service --output src/Components/Access/Article/Service --framework netstandard2.1
dotnet new classlib --name Kaylumah.AdventuresWithMock.Access.Author.Interface --output src/Components/Access/Author/Interface --framework netstandard2.1
dotnet new classlib --name Kaylumah.AdventuresWithMock.Access.Author.Service --output src/Components/Access/Author/Service --framework netstandard2.1
dotnet new classlib --name Kaylumah.AdventuresWithMock.Manager.Site.Interface --output src/Components/Manager/Site/Interface --framework netstandard2.1
dotnet new classlib --name Kaylumah.AdventuresWithMock.Manager.Site.Service --output src/Components/Manager/Site/Service --framework netstandard2.1
dotnet new xunit --name Test.Unit --output test/Unit --framework netcoreapp3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- Command to print file tree --&gt;
&lt;!-- ls -aR | grep &quot;:$&quot; | perl -pe &#39;s/:$//;s/[^-][^\/]*\//    /g;s/^    (\S)/└── \1/;s/(^    |    (?= ))/│   /g;s/    (\S)/└── \1/&#39; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-output&quot;&gt;└── src
│   └── Components
│   │   └── Access
│   │   │   └── Article
│   │   │   │   └── Interface
│   │   │   │   └── Service
│   │   │   └── Author
│   │   │   │   └── Interface
│   │   │   │   └── Service
│   │   └── Manager
│   │   │   └── Site
│   │   │   │   └── Interface
│   │   │   │   └── Service
└── test
│   └── Unit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If everything went fine, you should have the following directory structure on disk. I like to split my components into an interface definition project and an actual implementation project. This split, of course, means that every &lt;code&gt;.Service&lt;/code&gt; project needs to reference the corresponding &lt;code&gt;.Interface&lt;/code&gt; project via &lt;code&gt;ProjectReference&lt;/code&gt;. Because of our architecture, the SiteManager service needs to reference the interface projects of both access services. Finally, our unit test project needs to reference the service projects so we can test them.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You may be wondering why I specified &lt;code&gt;--framework&lt;/code&gt; after each dotnet new command; this is because it would otherwise default to &lt;code&gt;NET5.0&lt;/code&gt;, which would be fine for a blog post like this, but since NET5 is not LTS, I mostly abstain from using it in my projects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I will not include every little DTO as part of this article since those classes will be available as part of &lt;a href=&quot;https://github.com/kaylumah/AdventuresWithMock&quot; class=&quot;external&quot;&gt;the source code&lt;/a&gt; in the end. For now, assume we have created our implementation to look like this.&lt;/p&gt;
&lt;p&gt;Our Article Access&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Threading.Tasks;
using Kaylumah.AdventuresWithMock.Access.Article.Interface;

namespace Kaylumah.AdventuresWithMock.Access.Article.Service
{
    public class ArticleAccess : IArticleAccess
    {
        public Task&amp;lt;CreateArticlesResponse&amp;gt; CreateArticles(CreateArticlesRequest createArticlesRequest)
        {
            throw new NotImplementedException();
        }

        public Task DeleteArticles(DeleteArticlesRequest deleteArticlesRequest)
        {
            throw new NotImplementedException();
        }

        public Task&amp;lt;FilterArticleResponse&amp;gt; FilterArticles(FilterArticleCriteria filterArticleCriteria = null)
        {
            throw new NotImplementedException();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our Author Access&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Threading.Tasks;
using Kaylumah.AdventuresWithMock.Access.Author.Interface;

namespace Kaylumah.AdventuresWithMock.Access.Author.Service
{
    public class AuthorAccess : IAuthorAccess
    {
        public Task&amp;lt;FilterAuthorResponse&amp;gt; FilterAuthors(FilterAuthorCriteria filterAuthorCriteria = null)
        {
            throw new NotImplementedException();
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, our Site Manager, which should match our sequence diagram, looks like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System.Linq;
using System.Threading.Tasks;
using Kaylumah.AdventuresWithMock.Access.Article.Interface;
using Kaylumah.AdventuresWithMock.Access.Author.Interface;
using Kaylumah.AdventuresWithMock.Manager.Site.Interface;

namespace Kaylumah.AdventuresWithMock.Manager.Site.Service
{
    public class SiteManager : ISiteManager
    {

        private readonly IArticleAccess _articleAccess;
        private readonly IAuthorAccess _authorAccess;

        public SiteManager(IArticleAccess articleAccess, IAuthorAccess authorAccess)
        {
            _articleAccess = articleAccess;
            _authorAccess = authorAccess;
        }

        public async Task CreateArticle(Interface.CreateArticleRequest createArticleRequest)
        {
            // Hardcoded for now, would probably come from JWT user claim.
            var authorId = 666;

            var authorsResponse = await _authorAccess.FilterAuthors(new FilterAuthorCriteria {
                AuthorIds = new int[] { authorId }
            });

            var author = authorsResponse.Authors.SingleOrDefault(x =&amp;gt; x.Id.Equals(authorId));

            if (author == null)
            {
                return;
            }

            if (!author.Verfied)
            {
                return;
            }

            var article = new Access.Article.Interface.CreateArticleRequest
            { 
                AuthorId = authorId,
                Title = createArticleRequest.Title,
                Description = createArticleRequest.Content
            };

            var response = await _articleAccess.CreateArticles(new CreateArticlesRequest {
                CreateArticleRequests = new Access.Article.Interface.CreateArticleRequest[] {
                    article
                }
            });
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait just a minute! You forgot to implement the access components and only gave us the manager one. I did not ;-) It is to prove a point. Since we are going to mock our dependencies, we don&#39;t use the actual implementation.&lt;/p&gt;
&lt;p&gt;Thank you for bearing with me; now that we have all that in place, we can finally get to the heart of the matter and start our adventure with Mock.&lt;/p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;&lt;a href=&quot;#the-problem&quot;&gt;The Problem&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have yet to explain the reason behind the article. Let us look at how we might test this code traditionally with the following snippet.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Fact]
public async Task Test_SiteManager_CreateArticle_Traditionally()
{
    // Arange
    var authorAccessMock = new Mock&amp;lt;IAuthorAccess&amp;gt;();
    authorAccessMock.Setup(x =&amp;gt; x.FilterAuthors(It.Is&amp;lt;FilterAuthorCriteria&amp;gt;(p =&amp;gt; p.AuthorIds.Contains(666)))).ReturnsAsync(new FilterAuthorResponse {
        Authors = new Author[] {
            new Author {
                Id = 666,
                DisplayName = &amp;quot;Max&amp;quot;,
                Verfied = true
            }
        }
    });
    var articleAccessMock = new Mock&amp;lt;IArticleAccess&amp;gt;();
    articleAccessMock.Setup(x =&amp;gt; x.CreateArticles(It.IsAny&amp;lt;CreateArticlesRequest&amp;gt;())).ReturnsAsync(new CreateArticlesResponse {
        Articles = new Article[] {
            new Article {
                Id = 1,
                AuthorId = 666,
                Title = &amp;quot;...&amp;quot;,
                Description = &amp;quot;...&amp;quot;
            }
        }
    });
    ISiteManager sut = new SiteManager(articleAccessMock.Object, authorAccessMock.Object);

    // Act
    var request = new Kaylumah.AdventuresWithMock.Manager.Site.Interface.CreateArticleRequest { 
        Title = &amp;quot;Pretty Title&amp;quot;,
        Content = &amp;quot;# AdventuresWithMock ...&amp;quot;
    };
    await sut.CreateArticle(request);

    // Assert
    authorAccessMock.Verify(x =&amp;gt; x.FilterAuthors(It.IsAny&amp;lt;FilterAuthorCriteria&amp;gt;()), Times.Once);
    articleAccessMock.Verify(x =&amp;gt; x.CreateArticles(It.IsAny&amp;lt;CreateArticlesRequest&amp;gt;()), Times.Once);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is a lot of code to test a simple scenario. It is in its current form, even four lines longer than the code under test. Even worse, it&#39;s primarily boilerplate to set up the test. I often find myself repeating similar code for every test. Which is a violation of the &amp;quot;Don&#39;t Repeat Yourself&amp;quot; principle. So I am going to propose an alternative set up to my mock code. All you need to do is create a subclass from &lt;code&gt;Mock&amp;lt;T&amp;gt;&lt;/code&gt; for the system you want to stub, and you are good to go.&lt;/p&gt;
&lt;h2 id=&quot;mocking-data-access&quot;&gt;&lt;a href=&quot;#mocking-data-access&quot;&gt;Mocking Data Access&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We start with the AuthorsAccessMock. We will use our constructor to pass a &lt;code&gt;List&amp;lt;Author&amp;gt;&lt;/code&gt; and use Moq&#39;s &lt;code&gt;Setup&lt;/code&gt; method to return the internal state. Yes, that&#39;s right, because our mock is now a class we are stateful, this means we can now track state and changes on our mocks without relying on the &lt;code&gt;Verify&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System.Collections.Generic;
using System.Linq;
using Kaylumah.AdventuresWithMock.Access.Author.Interface;
using Moq;

namespace Test.Unit.Mocks
{
    public class AuthorAccessMock : Mock&amp;lt;IAuthorAccess&amp;gt;
    {
        public List&amp;lt;Author&amp;gt; Authors { get; }
        public AuthorAccessMock(List&amp;lt;Author&amp;gt; authors)
        {
            Authors = authors;

            Setup(x =&amp;gt; x.FilterAuthors(It.IsAny&amp;lt;FilterAuthorCriteria&amp;gt;()))
                .ReturnsAsync((FilterAuthorCriteria criteria) =&amp;gt; {

                    IQueryable&amp;lt;Author&amp;gt; result = Authors.AsQueryable();
                    if (criteria != null)
                    {
                        result = result.Where(x =&amp;gt; criteria.AuthorIds.Contains(x.Id));
                    }

                    return new FilterAuthorResponse {
                        Authors = result.ToArray()
                    };
                });
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how does this impact our test? We create a new AuthorAccessMock and pass it to our system under test. Keep in mind this is still a &lt;code&gt;Mock&amp;lt;T&amp;gt;&lt;/code&gt;, so to give it, we do &lt;code&gt;authorAccessMock.Object&lt;/code&gt;. Our new setup drastically decreases the setup code in my test, and at the same time, it increases the reusability of my mocks&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Fact]
public async Task Test_SiteManager_CreateArticle_RepoMocksDemo1()
{
    // Arange
    var authorAccessMock = new AuthorAccessMock(new List&amp;lt;Author&amp;gt; {
        new Author { Id = 666, DisplayName = &amp;quot;Max&amp;quot;, Verfied = false }
    });
    var articleAccessMock = new ArticleAccessMock();
    ISiteManager sut = new SiteManager(articleAccessMock.Object, authorAccessMock.Object);

    // Act
    var request = new Kaylumah.AdventuresWithMock.Manager.Site.Interface.CreateArticleRequest
    {
        Title = &amp;quot;Pretty Title&amp;quot;,
        Content = &amp;quot;# AdventuresWithMock ...&amp;quot;
    };
    await sut.CreateArticle(request);

    // Assert
    authorAccessMock.Verify(x =&amp;gt; x.FilterAuthors(It.IsAny&amp;lt;FilterAuthorCriteria&amp;gt;()), Times.Once);
    articleAccessMock.Verify(x =&amp;gt; x.CreateArticles(It.IsAny&amp;lt;CreateArticlesRequest&amp;gt;()), Times.Never);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our AuthorAccess was a bit boring. Let&#39;s extend on the stateful premise by building our ArticleAccessMock, which looks a lot like a CRUD repository. There are a couple of things in the following snippet I like to point out.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I created another representation of our Article class, and this is so that our mock implementation does a soft delete. Since we are stateful, we can then make tests on that premise.&lt;/li&gt;
&lt;li&gt;I also track the requests DTOs to my service using Moq&#39;s Callback mechanism. This way, I can make assertions regarding the actual input request.&lt;/li&gt;
&lt;li&gt;I partially moved away from constructor set up to demonstrate this pattern nicely complements Matthew&#39;s FluentMocks pattern.&lt;/li&gt;
&lt;li&gt;Lastly, I also added a custom verify method, which takes a func as an argument; this makes it possible to write any validation I can imagine against my internal state.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;
using System.Linq;
using Kaylumah.AdventuresWithMock.Access.Article.Interface;
using Moq;

namespace Test.Unit.Mocks
{
    public class ArticleAccessMock : Mock&amp;lt;IArticleAccess&amp;gt;
    {
        public class ArticleMock
        {
            public int Id { get;set; }
            public int AuthorId { get;set; }
            public string Title { get;set; }
            public string Content { get;set; }
            public bool Removed { get;set; }
        }

        public List&amp;lt;CreateArticlesRequest&amp;gt; CreateArticlesRequests { get; } = new List&amp;lt;CreateArticlesRequest&amp;gt;();
        public List&amp;lt;DeleteArticlesRequest&amp;gt; DeleteArticlesRequests { get; } = new List&amp;lt;DeleteArticlesRequest&amp;gt;();

        private List&amp;lt;ArticleMock&amp;gt; _articleState = new List&amp;lt;ArticleMock&amp;gt;();
        private int _numberOfArticlesBeforeCreate = 0;

        public ArticleAccessMock()
        {
            Setup(access =&amp;gt; access.CreateArticles(It.IsAny&amp;lt;CreateArticlesRequest&amp;gt;()))
                .Callback&amp;lt;CreateArticlesRequest&amp;gt;(request =&amp;gt; {
                    CreateArticlesRequests.Add(request);
                    _numberOfArticlesBeforeCreate = _articleState.Count;
                    var nextId = _numberOfArticlesBeforeCreate + 1;
                    foreach(var createArticleRequest in request.CreateArticleRequests)
                    {
                        _articleState.Add(new ArticleMock {
                            Id = nextId,
                            AuthorId = createArticleRequest.AuthorId,
                            Content = createArticleRequest.Description,
                            Title = createArticleRequest.Title,
                            Removed = false
                        });
                        nextId++;
                    }
                })
                .ReturnsAsync(() =&amp;gt; new CreateArticlesResponse {
                    Articles = _articleState
                    .Skip(_numberOfArticlesBeforeCreate)
                    .Select(x =&amp;gt; new Article
                    {
                        Id = x.Id,
                        AuthorId = x.AuthorId,
                        Description = x.Content,
                        Title = x.Title
                    })
                    .ToArray()
                });
            
            Setup(access =&amp;gt; access.DeleteArticles(It.IsAny&amp;lt;DeleteArticlesRequest&amp;gt;()))
                .Callback&amp;lt;DeleteArticlesRequest&amp;gt;(deleteArticlesRequest =&amp;gt; {
                    DeleteArticlesRequests.Add(deleteArticlesRequest);
                    foreach(var deleteArticleRequests in deleteArticlesRequest.DeleteArticleRequests)
                    {
                        var existing = _articleState.SingleOrDefault(article =&amp;gt; deleteArticleRequests.ArticleId == article.Id);
                        if (existing != null)
                        {
                            existing.Removed = true;
                        }
                    }
                });
        }

        public ArticleAccessMock SetupFilterArticles(List&amp;lt;Article&amp;gt; articles)
        {
            _articleState = articles.Select(x =&amp;gt; new ArticleMock {
                Id = x.Id,
                AuthorId = x.AuthorId,
                Content = x.Description,
                Title = x.Title,
                Removed = false
            }).ToList();

            Setup(x =&amp;gt; x.FilterArticles(It.IsAny&amp;lt;FilterArticleCriteria&amp;gt;()))
                .ReturnsAsync((FilterArticleCriteria criteria) =&amp;gt; {
                    IQueryable&amp;lt;ArticleMock&amp;gt; result = _articleState.AsQueryable();
                    if (criteria != null)
                    {
                        result = result.Where(x =&amp;gt; criteria.ArticleIds.Contains(x.Id));
                    }
                    return new FilterArticleResponse {
                        Articles = result
                            .Where(x =&amp;gt; !x.Removed)
                            .Select(x =&amp;gt; new Article {
                                Id = x.Id,
                                AuthorId = x.AuthorId,
                                Description = x.Content,
                                Title = x.Title
                            })
                            .ToArray()
                    };
                });

            return this;
        }

        public bool VerifyArticles(Func&amp;lt;List&amp;lt;ArticleMock&amp;gt;, bool&amp;gt; predicate)
        {
           return predicate(_articleState);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I usually would not write a test for my Moq code. The following snippet&#39;s purpose is to demonstrate the statefulness of our mocks. On the other hand, our mocks are now lightweight implementations of service, so why not test them!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Fact]
public async Task Test_ArticleAccessMock_StatefullDemo1()
{
    // Arange
    var articleAccessMock = new ArticleAccessMock()
        .SetupFilterArticles(new List&amp;lt;Article&amp;gt; {});
    var sut = articleAccessMock.Object;

    // Act
    var initialResponse = await sut.FilterArticles();
    var createResponse = await sut.CreateArticles(new CreateArticlesRequest {
        CreateArticleRequests = new CreateArticleRequest[] {
            new CreateArticleRequest {
                AuthorId = 666,
                Description = &amp;quot;1&amp;quot;,
                Title = &amp;quot;1&amp;quot;
            },
            new CreateArticleRequest {
                AuthorId = 666,
                Description = &amp;quot;2&amp;quot;,
                Title = &amp;quot;2&amp;quot;
            }
        }
    });

    var afterAddResponse = await sut.FilterArticles();

    await sut.DeleteArticles(new DeleteArticlesRequest {
        DeleteArticleRequests = new DeleteArticleRequest[] {
            new DeleteArticleRequest {
                ArticleId = createResponse.Articles.First().Id
            }
        }
    });

    var afterRemoveResponse = await sut.FilterArticles();


    // Assert
    initialResponse.Should().NotBeNull();
    initialResponse.Articles.Count().Should().Be(0, &amp;quot;No articles initially&amp;quot;);

    afterAddResponse.Should().NotBeNull();
    afterAddResponse.Articles.Count().Should().Be(2, &amp;quot;We created two articles&amp;quot;);

    afterRemoveResponse.Should().NotBeNull();
    afterRemoveResponse.Articles.Count().Should().Be(1, &amp;quot;There is only one article left&amp;quot;);

    // Verify result with predicate logic instead if Mock.Verify()
    articleAccessMock.VerifyArticles(articles =&amp;gt; articles.Count(x =&amp;gt; x.Removed) == 1).Should().BeTrue();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might ask yourself; Max, if you use a constructor to set up our mock, how would I deviate in my tests if I want to test error scenarios, for example? In that case, we might as well go full circle with the Fluent Mock approach. You could do it like the following snippet. You then choose to use the &#39;default&#39; stateful mock or call the Setup methods you want to use.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public ArticleAccessMock MakeStateful(List&amp;lt;Article&amp;gt; articles)
{
    return this
        .SetupFilterArticles(articles)
        .SetupDeleteArticles()
        .SetupCreateArticles();
}

public ArticleAccessMock SetupDeleteArticles() { /* ... */ }
public ArticleAccessMock SetupCreateArticles() { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;mocking-ilogger&quot;&gt;&lt;a href=&quot;#mocking-ilogger&quot;&gt;Mocking ILogger&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I did say that Adam&#39;s article also inspired me. So let us see how ILogger can implement stateful mocks. First, a quick reminder of what we are going to Mock. The &lt;a href=&quot;https://github.com/dotnet/runtime/blob/3cbbadee12cc95bd62c70786d5408a2277a21e0a/src/libraries/Microsoft.Extensions.Logging.Abstractions/src/ILogger.cs#L23&quot; class=&quot;external&quot;&gt;ILogger interface&lt;/a&gt; looks like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;/// &amp;lt;summary&amp;gt;
/// Writes a log entry.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;logLevel&amp;quot;&amp;gt;Entry will be written on this level.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&amp;quot;eventId&amp;quot;&amp;gt;Id of the event.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&amp;quot;state&amp;quot;&amp;gt;The entry to be written. Can be also an object.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&amp;quot;exception&amp;quot;&amp;gt;The exception related to this entry.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&amp;quot;formatter&amp;quot;&amp;gt;Function to create a &amp;lt;see cref=&amp;quot;string&amp;quot;/&amp;gt; message of the &amp;lt;paramref name=&amp;quot;state&amp;quot;/&amp;gt; and &amp;lt;paramref name=&amp;quot;exception&amp;quot;/&amp;gt;.&amp;lt;/param&amp;gt;
/// &amp;lt;typeparam name=&amp;quot;TState&amp;quot;&amp;gt;The type of the object to be written.&amp;lt;/typeparam&amp;gt;
void Log&amp;lt;TState&amp;gt;(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func&amp;lt;TState, Exception?, string&amp;gt; formatter);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can not express how happy I am that I don&#39;t need to call the Logger like that. Luckily Microsoft offers a different extension method for every occasion. Unfortunately, Moq cannot test extension methods. Luckily for me, Adam figured out how to test it.&lt;/p&gt;
&lt;p&gt;Create a &lt;code&gt;LoggerMock&amp;lt;T&amp;gt;&lt;/code&gt; class that implements &lt;code&gt;Mock&amp;lt;ILogger&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; we are not going to add something custom to it just yet.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using Microsoft.Extensions.Logging;
using Moq;

namespace Test.Unit.Mocks
{
    public class LoggerMock&amp;lt;T&amp;gt; : Mock&amp;lt;ILogger&amp;lt;T&amp;gt;&amp;gt;
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At the same time, we will use the final result from Adam&#39;s post as a helper method to test our logging.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static Mock&amp;lt;ILogger&amp;lt;T&amp;gt;&amp;gt; VerifyLogging&amp;lt;T&amp;gt;(this Mock&amp;lt;ILogger&amp;lt;T&amp;gt;&amp;gt; logger, string expectedMessage, LogLevel expectedLogLevel = LogLevel.Debug, Times? times = null)
{
    times ??= Times.Once();

    Func&amp;lt;object, Type, bool&amp;gt; state = (v, t) =&amp;gt; v.ToString().CompareTo(expectedMessage) == 0;

    logger.Verify(
        x =&amp;gt; x.Log(
            It.Is&amp;lt;LogLevel&amp;gt;(l =&amp;gt; l == expectedLogLevel),
            It.IsAny&amp;lt;EventId&amp;gt;(),
            It.Is&amp;lt;It.IsAnyType&amp;gt;((v, t) =&amp;gt; state(v, t)),
            It.IsAny&amp;lt;Exception&amp;gt;(),
            It.Is&amp;lt;Func&amp;lt;It.IsAnyType, Exception, string&amp;gt;&amp;gt;((v, t) =&amp;gt; true)), (Times)times);

    return logger;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that in place, let&#39;s update the manager to log.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class SiteManager : ISiteManager
{

    // ...
    
    private readonly ILogger _logger;

    public SiteManager(IArticleAccess articleAccess, IAuthorAccess authorAccess, ILogger&amp;lt;SiteManager&amp;gt; logger)
    {
        // ...
        _logger = logger;
    }

    public async Task CreateArticle(Interface.CreateArticleRequest createArticleRequest)
    {
        // Hardcoded for now, would probably come from JWT user claim.
        var authorId = 666;

        /// ...

        if (author == null)
        {
            _logger.LogWarning($&amp;quot;No author found for {authorId}&amp;quot;);
            return;
        }

        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To put it to the test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Fact]
public async Task Test_SiteManager_CreateArticle_TestLogging()
{
    // Arange
    var loggerMock = new LoggerMock&amp;lt;SiteManager&amp;gt;();
    var authorAccessMock = new AuthorAccessMock(new List&amp;lt;Author&amp;gt; {});
    var articleAccessMock = new ArticleAccessMock();
    ISiteManager sut = new SiteManager(articleAccessMock.Object, authorAccessMock.Object, loggerMock.Object);

    // Act
    var request = new Kaylumah.AdventuresWithMock.Manager.Site.Interface.CreateArticleRequest
    {
        Title = &amp;quot;Pretty Title&amp;quot;,
        Content = &amp;quot;# AdventuresWithMock ...&amp;quot;
    };
    await sut.CreateArticle(request);

    // Assert
    authorAccessMock.Verify(x =&amp;gt; x.FilterAuthors(It.IsAny&amp;lt;FilterAuthorCriteria&amp;gt;()), Times.Once);
    articleAccessMock.Verify(x =&amp;gt; x.CreateArticles(It.IsAny&amp;lt;CreateArticlesRequest&amp;gt;()), Times.Never);
    loggerMock.VerifyLogging(&amp;quot;No author found for 666&amp;quot;, Microsoft.Extensions.Logging.LogLevel.Warning);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait, did that just work on the first try? Did Adam&#39;s extension method not work on &lt;code&gt;Mock&amp;lt;ILogger&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;? Remember subclassing is an &lt;code&gt;is a&lt;/code&gt; relation ship which means that our MockLogger qualifies for this extension method.&lt;/p&gt;
&lt;p&gt;What would happen if have a lot of traffic and log thousands upon thousands of requests. In that case, we can move to an alternative for methods such as &lt;code&gt;LogInformation&lt;/code&gt;. For these scenarios, you can use &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/loggermessage?view=aspnetcore-5.0&quot; class=&quot;external&quot;&gt;LoggerMessage for high-performance logging&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using Microsoft.Extensions.Logging;

namespace Kaylumah.AdventuresWithMock.Manager.Site.Service
{
    public static class LoggerExtensions
    {
        private static readonly Action&amp;lt;ILogger, int, Exception&amp;gt; _authorNotVerfied =
            LoggerMessage.Define&amp;lt;int&amp;gt;(
                LogLevel.Information,
                EventIds.AuthorNotVerfied,
                &amp;quot;Author with Id {AuthorId} is not verfied!&amp;quot;
            );

        public static void LogAuthorNotVerfied(this ILogger logger, int authorId)
        {
            _authorNotVerfied(logger, authorId, null);
        }

        private static class EventIds
        {
            public static readonly EventId AuthorNotVerfied = new(100, nameof(AuthorNotVerfied));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Fact]
public async Task Test_SiteManager_CreateArticle_TestLoggingExtensionMethod()
{
    // Arange
    var loggerMock = new LoggerMock&amp;lt;SiteManager&amp;gt;();
    var authorAccessMock = new AuthorAccessMock(new List&amp;lt;Author&amp;gt; {
        new Author { Id = 666, DisplayName = &amp;quot;Max&amp;quot;, Verfied = false }
    });
    var articleAccessMock = new ArticleAccessMock();
    ISiteManager sut = new SiteManager(articleAccessMock.Object, authorAccessMock.Object, loggerMock.Object);

    // Act
    var request = new Kaylumah.AdventuresWithMock.Manager.Site.Interface.CreateArticleRequest
    {
        Title = &amp;quot;Pretty Title&amp;quot;,
        Content = &amp;quot;# AdventuresWithMock ...&amp;quot;
    };
    await sut.CreateArticle(request);

    // Assert
    authorAccessMock.Verify(x =&amp;gt; x.FilterAuthors(It.IsAny&amp;lt;FilterAuthorCriteria&amp;gt;()), Times.Once);
    articleAccessMock.Verify(x =&amp;gt; x.CreateArticles(It.IsAny&amp;lt;CreateArticlesRequest&amp;gt;()), Times.Never);
    loggerMock.VerifyLogging(&amp;quot;Author with Id 666 is not verfied!&amp;quot;, Microsoft.Extensions.Logging.LogLevel.Information);
    loggerMock.VerifyEventIdWasCalled(new Microsoft.Extensions.Logging.EventId(100, &amp;quot;AuthorNotVerfied&amp;quot;));

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You are probably as surprised as I was that it did not work. As it turns out, LoggerMessage actual checks against LogLevel enabled. So add the following to our LoggerMock.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public LoggerMock&amp;lt;T&amp;gt; SetupLogLevel(LogLevel logLevel, bool enabled = true)
{
    Setup(x =&amp;gt; x.IsEnabled(It.Is&amp;lt;LogLevel&amp;gt;(p =&amp;gt; p.Equals(logLevel))))
        .Returns(enabled);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is one last improvement I wish to make to our LoggerMock. Like our stateful repository mocks, I feel it would be beneficial to capture everything that goes into our mock—in my opinion, using Predicates and Linq gives me more control over my assertions than using mocks internals.&lt;/p&gt;
&lt;p&gt;Our final implementation looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;
using Microsoft.Extensions.Logging;
using Moq;

namespace Test.Unit.Mocks
{
    public class LoggerMock&amp;lt;T&amp;gt; : Mock&amp;lt;ILogger&amp;lt;T&amp;gt;&amp;gt;
    {
        public class LogMessageMock
        {
            public LogLevel LogLevel { get;set; }
            public EventId Event { get;set; }
            public string Message { get;set; }
        }

        public List&amp;lt;LogMessageMock&amp;gt; Messsages { get; } = new List&amp;lt;LogMessageMock&amp;gt;();

        public LoggerMock()
        {
            Setup(x =&amp;gt; x.Log(
                    It.IsAny&amp;lt;LogLevel&amp;gt;(),
                    It.IsAny&amp;lt;EventId&amp;gt;(),
                    It.Is&amp;lt;It.IsAnyType&amp;gt;((v, t) =&amp;gt; true),
                    It.IsAny&amp;lt;Exception&amp;gt;(),
                    It.Is&amp;lt;Func&amp;lt;It.IsAnyType, Exception, string&amp;gt;&amp;gt;((v, t) =&amp;gt; true)
                )
            )
            .Callback(new InvocationAction(invocation =&amp;gt;
            {
                // https://stackoverflow.com/questions/52707702/how-do-you-mock-ilogger-loginformation
                // https://github.com/moq/moq4/issues/918
                var logLevel = (LogLevel)invocation.Arguments[0];
                var eventId = (EventId)invocation.Arguments[1];
                var state = invocation.Arguments[2];
                var exception = (Exception?)invocation.Arguments[3];
                var formatter = invocation.Arguments[4];

                var invokeMethod = formatter
                    .GetType()
                    .GetMethod(&amp;quot;Invoke&amp;quot;);

                var logMessage = (string?)invokeMethod?.Invoke(formatter, new[] { state, exception });
                Messsages.Add(new LogMessageMock {
                    Event = eventId,
                    LogLevel = logLevel,
                    Message = logMessage
                });
            }));
        }

        public LoggerMock&amp;lt;T&amp;gt; SetupLogLevel(LogLevel logLevel, bool enabled = true)
        {
            Setup(x =&amp;gt; x.IsEnabled(It.Is&amp;lt;LogLevel&amp;gt;(p =&amp;gt; p.Equals(logLevel))))
                .Returns(enabled);
            return this;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;mocking-httpclient&quot;&gt;&lt;a href=&quot;#mocking-httpclient&quot;&gt;Mocking HttpClient&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Even though our article is getting to be on the length side, I found it helpful to include at least one more example. I could rewrite the filesystem sample I mentioned to match this pattern, but I decided to do that later. I thought it would be more useful to look into mocking an HttpClient. One option would be to hide HttpClient behind an interface, but since our ArticleAccess is already the lowest point in our architecture, I see no need to hide that we use a HttpClient.&lt;/p&gt;
&lt;p&gt;Since this is purely a demonstration, I am not going to set up an HTTP Server. Luckily we can use https://jsonplaceholder.typicode.com/posts for our needs. Suppose our CreateArticles method looked like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public async Task&amp;lt;CreateArticlesResponse&amp;gt; CreateArticles(CreateArticlesRequest createArticlesRequest)
{
    // NOTE: not going to call them in a loop, just for demo purposes.
    var json = JsonSerializer.Serialize(createArticlesRequest.CreateArticleRequests.First());
    var response = await _httpClient.PostAsync(&amp;quot;https://jsonplaceholder.typicode.com/posts&amp;quot;, new StringContent(json));
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception(&amp;quot;Something went horribly wrong!&amp;quot;);
    }
    var responseText = await response.Content.ReadAsStringAsync();
    // Map it to response
    return new CreateArticlesResponse {};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, you cannot achieve this by mocking HttpClient. You need to Mock HttpMessageHandler. Depending on your needs, it might look something like the following snippet. (Based on &lt;a href=&quot;https://stackoverflow.com/a/57199040/1936600&quot; class=&quot;external&quot;&gt;this stackoverflow answer&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Moq;
using Moq.Language;
using Moq.Protected;

namespace Test.Unit.Mocks
{
    public class HttpClientMock : Mock&amp;lt;HttpMessageHandler&amp;gt;
    {
        private readonly List&amp;lt;Tuple&amp;lt;HttpStatusCode, HttpContent&amp;gt;&amp;gt; _responses;
        public HttpClientMock(List&amp;lt;Tuple&amp;lt;HttpStatusCode, HttpContent&amp;gt;&amp;gt; responses) : base(MockBehavior.Strict)
        {
            _responses = responses;
            SetupResponses();
        }

        private void SetupResponses()
        {
            var handlerPart = this.Protected().SetupSequence&amp;lt;Task&amp;lt;HttpResponseMessage&amp;gt;&amp;gt;(
              &amp;quot;SendAsync&amp;quot;,
              ItExpr.IsAny&amp;lt;HttpRequestMessage&amp;gt;(),
              ItExpr.IsAny&amp;lt;CancellationToken&amp;gt;()
           );

            foreach (var item in _responses)
            {
                handlerPart = AdddReturnPart(handlerPart, item.Item1, item.Item2);
            }
        }

        private ISetupSequentialResult&amp;lt;Task&amp;lt;HttpResponseMessage&amp;gt;&amp;gt; AdddReturnPart(ISetupSequentialResult&amp;lt;Task&amp;lt;HttpResponseMessage&amp;gt;&amp;gt; handlerPart,
        HttpStatusCode statusCode, HttpContent content)
        {
            return handlerPart.ReturnsAsync(new HttpResponseMessage()
            {
                StatusCode = statusCode,
                Content = content
            });
        }

        public static implicit operator HttpClient (HttpClientMock mock)
        {
            // Since neither HttpClient or HttpClientMock is an interface we can use implicit operator to convert.
            // Safes us a call to mock.Object in the test code.
            return new HttpClient(mock.Object) {};
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The corresponding test would look like&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;[Fact]
public async Task Test_ArticleAccess_Returns200OK()
{
    var createArticleResponse = new StringContent(&amp;quot;{ &#39;id&#39;:&#39;anId&#39; }&amp;quot;, Encoding.UTF8, &amp;quot;application/json&amp;quot;);
    var httpClient = new HttpClientMock(new List&amp;lt;Tuple&amp;lt;HttpStatusCode, HttpContent&amp;gt;&amp;gt; {
        new Tuple&amp;lt;HttpStatusCode, HttpContent&amp;gt;(HttpStatusCode.OK, createArticleResponse),
    });
    var articleAccess = new ArticleAccess(httpClient);
    await articleAccess.CreateArticles(new CreateArticlesRequest{
        CreateArticleRequests = new CreateArticleRequest[] {
            new CreateArticleRequest {
                AuthorId = 666,
                Description = &amp;quot;...&amp;quot;,
                Title = &amp;quot;Demo&amp;quot;
            }
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;That concludes my experiment for the day. I have shown three instances where you can apply your custom subclasses of Mock&lt;T&gt;. The way I see it, it offers three distinct advantages:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Test code and mock code is separated.&lt;/li&gt;
&lt;li&gt;Mock code is reusable across tests.&lt;/li&gt;
&lt;li&gt;Stateful mocking allows for more readable verification in tests.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, creating a mock library will take some time. You could argue if it&#39;s worth the time to make a duplicate, albeit a simplified version of your data access. My personal opinion is that it makes debugging and reasoning about my tests easier than taking a deep dive in Invocations and Verify mock provides. As I have hopefully demonstrated is that one does not exclude the other. I think it can complement one and other.&lt;/p&gt;
&lt;p&gt;I am glad about the early results of my experiment, hence me writing this blog post. Over time you can evolve these mocks to be even better. For example, change tracking of entities could potentially be used cross mock. The HttpClientMock could use some more love. Imagine hiding every detail like StatusCode, HttpResponseMessage from the tester. I could have saved it for another blog, but I shared this abstraction to start a dialogue with my team about testing and test set up.&lt;/p&gt;
&lt;p&gt;As always, if you have any questions, feel free to reach out. I am curious to hear what you all think about this approach. Do you have suggestions or alternatives? I would love to hear about them.&lt;/p&gt;
&lt;p&gt;The corresponding source code for this article is on &lt;a href=&quot;https://github.com/kaylumah/AdventuresWithMock&quot; class=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See you next time, stay healthy and happy coding to all &#129528;!&lt;/p&gt;
&lt;h2 id=&quot;sources&quot;&gt;&lt;a href=&quot;#sources&quot;&gt;Sources&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://exceptionnotfound.net/using-moq-to-create-fluent-test-classes-in-asp-net-core/&quot; class=&quot;external&quot;&gt;Fluent Mocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://adamstorr.azurewebsites.net/blog/mocking-ilogger-with-moq&quot; class=&quot;external&quot;&gt;Testing ILogger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Moq/moq4/wiki/Quickstart&quot; class=&quot;external&quot;&gt;Moq Quickstart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/webcom-engineering-and-product/a-cleaner-way-to-create-mocks-in-net-6e039c3d1db0&quot; class=&quot;external&quot;&gt;Cleaner way to create mocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/57199040/1936600&quot; class=&quot;external&quot;&gt;Testing HttpClient&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
        </content>
        
        <summary>An experiment to create reusable mocks in my testing code.</summary>
        
        
        <category term="CSharp" />
        
        <category term="Moq" />
        
        <category term="Testing" />
        
        
        
            
                
            

            <media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kaylumah.nl/assets/images/posts/20210411/approach-to-writing-mocks/cover_image.png" />
            <media:content medium="image" url="https://kaylumah.nl/assets/images/posts/20210411/approach-to-writing-mocks/cover_image.png" xmlns:media="http://search.yahoo.com/mrss/" />

        
    </entry>
    
    <entry>
        <id>https://kaylumah.nl/2021/03/27/set-nuget-metadata-via-msbuild.html</id>
        <title>Set NuGet metadata via MSBuild</title>
        <author>
            <name>Max Hamulyák</name>
            <email>max@kaylumah.nl</email>
            <uri>https:/kaylumah.nl</uri>
        </author>
        <published>2021-03-27T00:00:00.0000000+00:00</published>
        <updated>2021-03-27T00:00:00.0000000+00:00</updated>
        <link href="https://kaylumah.nl/2021/03/27/set-nuget-metadata-via-msbuild.html" />
        <content type="html">
            &lt;p&gt;For .NET, the standard mechanism for sharing packages is NuGet. A &lt;code&gt;.nupkg&lt;/code&gt; file is an archive that contains your compiled code (DLLs), other files related to your code, and a manifest containing metadata (&lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/what-is-nuget&quot; class=&quot;external&quot;&gt;source&lt;/a&gt;). This blog post will show you how data in this manifest can be controlled by using MSBuild.&lt;/p&gt;
&lt;p&gt;For simplification purposes, my sample project will consist of only a single class library project. I like you to keep in mind that this would scale to many projects as Microsoft did with the &lt;a href=&quot;https://github.com/dotnet/runtime&quot; class=&quot;external&quot;&gt;&amp;quot;Microsoft.Extensions packages&amp;quot;&lt;/a&gt;. The sky is the limit.&lt;/p&gt;
&lt;h2 id=&quot;setup&quot;&gt;&lt;a href=&quot;#setup&quot;&gt;Setup&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are bits of this demo that work cross-platform and bits that require you to run on Windows. For example, I like the control the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/&quot; class=&quot;external&quot;&gt;.NET CLI&lt;/a&gt; gives me when creating a new project. If you prefer to use &lt;a href=&quot;https://visualstudio.microsoft.com/vs/&quot; class=&quot;external&quot;&gt;Visual Studio&lt;/a&gt;, the result will remain the same.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ dotnet new sln

The template &amp;quot;Solution File&amp;quot; was created successfully.

$ dotnet new classlib --framework netstandard2.0 --output src/Kaylumah.Logging.Extensions.Abstractions

The template &amp;quot;Class library&amp;quot; was created successfully.

Processing post-creation actions...
Running &#39;dotnet restore&#39; on src/Kaylumah.Logging.Extensions.Abstractions\Kaylumah.Logging.Extensions.Abstractions.csproj...
  Determining projects to restore...
  Restored C:\Projects\NugetMetadata\src\Kaylumah.Logging.Extensions.Abstractions\Kaylumah.Logging.Extensions.Abstractions.csproj (in 84 ms).
Restore succeeded.

$ dotnet sln add src/Kaylumah.Logging.Extensions.Abstractions/Kaylumah.Logging.Extensions.Abstractions.csproj

Project `src\Kaylumah.Logging.Extensions.Abstractions\Kaylumah.Logging.Extensions.Abstractions.csproj` added to the solution.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I chose &lt;code&gt;Kaylumah.Logging.Extensions.Abstractions&lt;/code&gt; to keep inline and in style with the extension packages Microsoft provides. By default, the namespace of the assembly sets the unique package identifier. Of course, this only matters when publishing the package to a NuGet source like &lt;code&gt;https://nuget.org&lt;/code&gt;. That is not this article&#39;s scope, as publishing the default template with only the empty &lt;code&gt;Class1.cs&lt;/code&gt; file would not benefit anyone by sharing it.&lt;/p&gt;
&lt;h2 id=&quot;why-do-we-even-need-metadata-in-our-packages&quot;&gt;&lt;a href=&quot;#why-do-we-even-need-metadata-in-our-packages&quot;&gt;Why do we even need metadata in our packages?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before showing you how I set metadata, I like to show you what happens without specifying any metadata. You can run the command &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-pack#description&quot; class=&quot;external&quot;&gt;&lt;code&gt;dotnet pack&lt;/code&gt;&lt;/a&gt; for a single project or an entire solution. If you do it for the solution, only projects that are &lt;code&gt;&amp;lt;IsPackable&amp;gt;true&amp;lt;/IsPackable&amp;gt;&lt;/code&gt; generate a package. The class library we created uses the &lt;code&gt;Microsoft.NET.Sdk&lt;/code&gt; and is packable by default.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ dotnet pack

Microsoft (R) Build Engine version 16.8.3+39993bd9d for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  All projects are up-to-date for restore.
  Kaylumah.Logging.Extensions.Abstractions -&amp;gt; C:\Projects\NugetMetadata\src\Kaylumah.Logging.Extensions.Abstractions\bin\Debug\netstandard2.0\Kaylumah.Logging.Extensions.Abstractions.dll
  Successfully created package &#39;C:\Projects\NugetMetadata\src\Kaylumah.Logging.Extensions.Abstractions\bin\Debug\Kaylumah.Logging.Extensions.Abstractions.1.0.0.nupkg&#39;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command generated the package in my bin folder. Since I did not specify a configuration, it chose the default configuration, which is Debug. So how do we inspect &lt;code&gt;Kaylumah.Logging.Extensions.Abstractions.1.0.0.nupkg&lt;/code&gt;? My prefered way is the &lt;a href=&quot;https://github.com/NuGetPackageExplorer/NuGetPackageExplorer&quot; class=&quot;external&quot;&gt;NuGet Package Explorer&lt;/a&gt;, which is unfortunately only available on Windows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/001_npe_initial_metadata.png&quot; alt=&quot;Without Metadata in Package Explorer&quot; /&gt;&lt;/p&gt;
&lt;p&gt;There seems to be no metadata set by default. Let&#39;s, for a quick moment, compare it to what Microsoft adds to its packages. We can do this by downloading &lt;a href=&quot;https://www.nuget.org/api/v2/package/Microsoft.Extensions.Logging.Console/3.1.13&quot; class=&quot;external&quot;&gt;the package&lt;/a&gt; from nuget.org and view it like we just did for &lt;code&gt;Kaylumah.Logging.Extensions.Abstractions.1.0.0.nupkg&lt;/code&gt;. Alternatively, the NuGet Package Explorer also supports viewing metadata from remote sources such as nuget.org.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/002_console_logger_info.png&quot; alt=&quot;Microsoft Extensions Logging Metadata in Package Explorer&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Now that is what I call metadata. Remember that &lt;code&gt;.nupkg&lt;/code&gt; files are archives; this means we can easily verify what the explorer was telling us about our package.  You can do this by changing the extension from &lt;code&gt;.nupkg&lt;/code&gt; to &lt;code&gt;.zip&lt;/code&gt; and then extracting it. It contains &lt;code&gt;Kaylumah.Logging.Extensions.Abstractions.nuspec&lt;/code&gt;, which is the manifest I was talking about in the introduction. At the moment, it looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;package xmlns=&amp;quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&amp;quot;&amp;gt;
  &amp;lt;metadata&amp;gt;
    &amp;lt;id&amp;gt;Kaylumah.Logging.Extensions.Abstractions&amp;lt;/id&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
    &amp;lt;authors&amp;gt;Kaylumah.Logging.Extensions.Abstractions&amp;lt;/authors&amp;gt;
    &amp;lt;requireLicenseAcceptance&amp;gt;false&amp;lt;/requireLicenseAcceptance&amp;gt;
    &amp;lt;description&amp;gt;Package Description&amp;lt;/description&amp;gt;
    &amp;lt;dependencies&amp;gt;
      &amp;lt;group targetFramework=&amp;quot;.NETStandard2.0&amp;quot; /&amp;gt;
    &amp;lt;/dependencies&amp;gt;
  &amp;lt;/metadata&amp;gt;
&amp;lt;/package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So as expected, it matches what NuGet Package Explorer shows us. The default for both id and authors is the assembly namespace, whereas description defaults to &amp;quot;Package Description&amp;quot;, which tells our users nothing about what the package does.&lt;/p&gt;
&lt;h2 id=&quot;how-do-we-set-metadata&quot;&gt;&lt;a href=&quot;#how-do-we-set-metadata&quot;&gt;How do we set metadata?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that we have covered our basis, we can finally explain how we can set metadata via MSBuild.&lt;/p&gt;
&lt;h3 id=&quot;set-metadata-from-csproj&quot;&gt;&lt;a href=&quot;#set-metadata-from-csproj&quot;&gt;Set metadata from csproj&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Since we are working on a single project, the logical place to set metadata is by editing our .csproj file. I will not cover every property today, so I refer you to &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target&quot; class=&quot;external&quot;&gt;pack target docs&lt;/a&gt; link. I will, however, cover properties I often use in my projects.&lt;/p&gt;
&lt;p&gt;So behind the scenes, what happens is that specific MSBuild properties map to properties in the .nuspec file. We have to either edit the existing &lt;code&gt;PropertyGroup&lt;/code&gt; in our file or add one to set properties. In my opinion, every package should contain branding (like authors, company and copyright information), a helpful description and categorized by a series of tags. So in the example below, I have set these values.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;Authors&amp;gt;Max Hamuly&#225;k&amp;lt;/Authors&amp;gt;
    &amp;lt;!-- Note: Company does not get added to the .nuspec but it is part of the Assembly...Attribute so I often set them all --&amp;gt;
    &amp;lt;Company&amp;gt;Kaylumah&amp;lt;/Company&amp;gt;
    &amp;lt;Description&amp;gt;Logging abstractions for Kaylumah.&amp;lt;/Description&amp;gt;
    &amp;lt;PackageTags&amp;gt;logging;abstractions&amp;lt;/PackageTags&amp;gt;
    &amp;lt;Copyright&amp;gt;Copyright (c) 2021 Kaylumah&amp;lt;/Copyright&amp;gt; 
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run &lt;code&gt;dotnet pack&lt;/code&gt; now, we can immediately see that our package no longer has empty metadata.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/003_npe_author_metadata.png&quot; alt=&quot;With Author Metadata in Package Explorer&quot; /&gt;&lt;/p&gt;
&lt;p&gt;You can also verify this in Visual Studio by checking your projects properties and clicking on the &lt;code&gt;Package&lt;/code&gt; tab.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/004_vs2019_author_metadata.png&quot; alt=&quot;With Author Metadata in VS2019&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In the introduction, I talked about what exactly is a NuGet package. We are now at the part regarding other files. Since we already took care of branding, let us also add an icon. Our code is under license; how do we include it in the package?&lt;/p&gt;
&lt;p&gt;Add files named &lt;code&gt;Logo.png&lt;/code&gt; and &lt;code&gt;LICENSE&lt;/code&gt; to the folder containing our project. We can then use the tags &lt;code&gt;PackageIcon&lt;/code&gt; and &lt;code&gt;PackageLicenseFile&lt;/code&gt; respectfully. We also need to tell MSBuild that these files should be part of the package. The updated project file looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;Authors&amp;gt;Max Hamuly&#225;k&amp;lt;/Authors&amp;gt;
    &amp;lt;Company&amp;gt;Kaylumah&amp;lt;/Company&amp;gt;
    &amp;lt;Description&amp;gt;Logging abstractions for Kaylumah.&amp;lt;/Description&amp;gt;
    &amp;lt;PackageTags&amp;gt;logging;abstractions&amp;lt;/PackageTags&amp;gt;
    &amp;lt;Copyright&amp;gt;Copyright (c) 2021 Kaylumah&amp;lt;/Copyright&amp;gt;
    &amp;lt;PackageIcon&amp;gt;Logo.png&amp;lt;/PackageIcon&amp;gt;
    &amp;lt;PackageLicenseFile&amp;gt;LICENSE&amp;lt;/PackageLicenseFile&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;None Include=&amp;quot;Logo.png&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot; /&amp;gt;
    &amp;lt;None Include=&amp;quot;LICENSE&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot;/&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/005_npe_includingfiles_metadata.png&quot; alt=&quot;Including FileMetadata&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Regarding these files, I like to say a couple of things before moving on to more advanced use cases.
There is more than one way to set both the Icon and the License files for starters, which the Microsoft Docs &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets#pack-target&quot; class=&quot;external&quot;&gt;describe&lt;/a&gt;. Both used to have a &lt;code&gt;Url&lt;/code&gt; variant that would link to the Icon or License in question. Both of those options are now deprecated, and in the case of &lt;code&gt;PackageLicenseFile&lt;/code&gt;, the alternative is  &lt;code&gt;PackageLicenseExpression&lt;/code&gt;, which uses &lt;code&gt;SDPX&lt;/code&gt; license identifiers.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;: For backwards compatibility, &lt;code&gt;PackageLicenseUrl&lt;/code&gt; gets populated with &lt;code&gt;https://docs.microsoft.com/en-us/nuget/consume-packages/finding-and-choosing-packages#license-url-deprecation&lt;/code&gt; if you choose to use &lt;code&gt;PackageLicenseFile&lt;/code&gt; and with &lt;code&gt;https://licenses.nuget.org/MIT&lt;/code&gt; for example, if your SPDX would be MIT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The second point I like to raise is regarding the file names.
In my example, the value for &lt;code&gt;PackageIcon&lt;/code&gt; and the name of my icon file match precisely; this is not necessary. What does matter is the name we specify in the package path. Failing to do so would, for example, trigger &amp;quot;NU5046: The icon file &#39;NotAnIcon.png&#39; does not exist in the package. See a couple of samples below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- Visible &#39;False&#39; hides the file in the Visual Studio explorer but still packages it under Logo.png --&amp;gt;
&amp;lt;None Include=&amp;quot;Logo.png&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot; Visible=&amp;quot;false&amp;quot; /&amp;gt;

&amp;lt;!-- Link changes the name Visual Studio displays in the explorer but still packages it under Logo.png --&amp;gt;
&amp;lt;None Include=&amp;quot;Logo.png&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot; Link=&amp;quot;NotAnIcon.png&amp;quot; /&amp;gt;

&amp;lt;!-- PackagePath rewrites the filename to Icon.png so PackageIcon remains unchanged --&amp;gt;
&amp;lt;None Include=&amp;quot;KaylumahLogo.png&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;Icon.png&amp;quot; /&amp;gt;

&amp;lt;!-- PackagePath rewrites the filename to KaylumahLogo.png so set PackageIcon to &amp;quot;KaylumahLogo&amp;quot; --&amp;gt;
&amp;lt;None Include=&amp;quot;Icon.png&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;KaylumahLogo.png&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rewriting via package path only works for files with an extension. For historical purposes, both NuGet and MSBuild treat these files as directories. If we had used &lt;code&gt;LICENSE.txt&lt;/code&gt; over &lt;code&gt;LICENSE&lt;/code&gt;, we would have been able to modify the name in the package. However, our &lt;code&gt;LICENSE&lt;/code&gt; file can apply both the &lt;code&gt;Visible&lt;/code&gt; and the &lt;code&gt;Link&lt;/code&gt; example. For more information regarding Package Icons, see &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-an-icon-image-file&quot; class=&quot;external&quot;&gt;package-icon&lt;/a&gt;. For packing licenses without an extension see &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-a-file-without-an-extension&quot; class=&quot;external&quot;&gt;package-license-1&lt;/a&gt;, and licenses with an extension see &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets#packing-a-license-expression-or-a-license-file&quot; class=&quot;external&quot;&gt;package-license-2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Keep in mind that by adding both Icon and License files to the package, the overall package size slightly increases; this can cause slower restore times on initial package downloads. This performance penalty is a trade-off you have to decide for your self. Given today&#39;s network speeds, I think the impact isn&#39;t noticeable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;set-metadata-for-multiple-projects&quot;&gt;&lt;a href=&quot;#set-metadata-for-multiple-projects&quot;&gt;Set metadata for multiple projects&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;So lets for a moment, assume our project is a huge success. We are creating more and more extension libraries. Think about the vast number of packages in &lt;code&gt;dotnet/runtime&lt;/code&gt;. Even if we would only include an implementation for &lt;code&gt;.Abstractions&lt;/code&gt; package, it would be very time consuming to do this for every project. It would also violate the &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot; class=&quot;external&quot;&gt;DRY principle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To get started, create a file called &lt;code&gt;Directory.Build.props&lt;/code&gt; at the root of your solution. The way Microsoft handles this file, and in precisely that casing, is starting from your project folder; it goes up till it finds a match or it reaches the root of your drive. This &lt;code&gt;Directory.Build.props&lt;/code&gt; file follows the same syntax we use in our &lt;code&gt;.csproj&lt;/code&gt; files. To demonstrate, remove only the &lt;code&gt;Copyright&lt;/code&gt; tag from the project and recreate it in the &lt;code&gt;Directory.Build.props&lt;/code&gt; file. Now is the perfect moment to also demonstrate something I have not yet told you. We are using MSBuild to populate our metadata, and thus we can use the full force of MSBuild. For example, we can reference other variables and even use built-in functions. So the thing about our current Copyright implementation is that if after &lt;code&gt;31/12/2021&lt;/code&gt; I want to release the next version, I have to remember to update my copyright notice. We can achieve this by setting the copyright tag like below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Project&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;Copyright&amp;gt;Copyright &#169; $(Company) $([System.DateTime]::Now.Year)&amp;lt;/Copyright&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/006_npe_buildpropsv1.png&quot; alt=&quot;Using BuildProps V1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;What happened? Something is wrong; why do I see the copyright year 2021, but not my company name? Before explaining it, let me prove it by adding a company tag to the &lt;code&gt;Directory.Build.props&lt;/code&gt; with a different value. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Project&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;Company&amp;gt;NotKaylumah&amp;lt;/Company&amp;gt;
        &amp;lt;Copyright&amp;gt;Copyright &#169; $(Company) $([System.DateTime]::Now.Year)&amp;lt;/Copyright&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike the &lt;code&gt;Copyright&lt;/code&gt; tag do not remove the &lt;code&gt;Company&lt;/code&gt; tag from the &lt;code&gt;.csproj&lt;/code&gt; file. The result, this time, is a little different.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/007_npe_buildpropsv2.png&quot; alt=&quot;Using BuildProps V2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It appears that I have two different values for &lt;code&gt;Company&lt;/code&gt;; this happens because &lt;code&gt;Directory.Build.props&lt;/code&gt; gets imported before your project, and &lt;code&gt;Directory.Build.targets&lt;/code&gt; gets imported after. The latest registration wins. That is why if we would read the &lt;code&gt;System.Reflection.AssemblyCopyrightAttribute&lt;/code&gt; the value for &lt;code&gt;Company&lt;/code&gt; is &amp;quot;Kaylumah&amp;quot;, but when we set &lt;code&gt;Copyright&lt;/code&gt;, it is still &amp;quot;NotKaylumah&amp;quot;. You can verify this behaviour by running the preprocess command (&lt;code&gt;dotnet build -pp:fullproject.xml&lt;/code&gt;). See &lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-command-line-reference?view=vs-2019&quot; class=&quot;external&quot;&gt;msbuild comand line reference&lt;/a&gt; for an explanation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Word of caution, you should not set every property this way. You should only set the values that are shared cross-project. For example, &lt;code&gt;Company&lt;/code&gt; and &lt;code&gt;Copyright&lt;/code&gt; are likely to be the same for every project. The &lt;code&gt;Authors&lt;/code&gt; and &lt;code&gt;PackageTags&lt;/code&gt; could be project-specific; heck, even &lt;code&gt;Description&lt;/code&gt; could be reused if so desired. One thing for sure is that &lt;code&gt;Id&lt;/code&gt; can not be recycled since every package requires a unique Id.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Project&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;Authors&amp;gt;Max Hamuly&#225;k&amp;lt;/Authors&amp;gt;
        &amp;lt;Company&amp;gt;Kaylumah&amp;lt;/Company&amp;gt;
        &amp;lt;Description&amp;gt;Logging abstractions for Kaylumah.&amp;lt;/Description&amp;gt;
        &amp;lt;Copyright&amp;gt;Copyright &#169; $(Company) $([System.DateTime]::Now.Year)&amp;lt;/Copyright&amp;gt;
        &amp;lt;PackageTags&amp;gt;logging;abstractions&amp;lt;/PackageTags&amp;gt;
        &amp;lt;PackageIcon&amp;gt;Logo.png&amp;lt;/PackageIcon&amp;gt;
        &amp;lt;PackageLicenseFile&amp;gt;LICENSE&amp;lt;/PackageLicenseFile&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;

    &amp;lt;ItemGroup&amp;gt;
        &amp;lt;None Include=&amp;quot;$(MSBuildThisFileDirectory)Logo.png&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot; /&amp;gt;
        &amp;lt;None Include=&amp;quot;$(MSBuildThisFileDirectory)LICENSE&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot; /&amp;gt;
    &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/008_npe_buildpropsv3.png&quot; alt=&quot;Using BuildProps V3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In case you are wondering where did &lt;code&gt;$(MSBuildThisFileDirectory)&lt;/code&gt; come from, it is one of the predefined MSBuild variables you can use. It allows us to set the path without thinking about relative file paths; for other variables, see the &lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2019&quot; class=&quot;external&quot;&gt;Microsoft Docs&lt;/a&gt; on the topic.&lt;/p&gt;
&lt;h3 id=&quot;bonus-chapter&quot;&gt;&lt;a href=&quot;#bonus-chapter&quot;&gt;Bonus Chapter&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I have referred to the list of properties before. There are a couple of handy ones we have not yet discussed. I am talking about the repository fields, making sure that an artefact can always trace back to a specific revision of your source code.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;NuSpec&lt;/th&gt;
&lt;th&gt;MSBuild&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Repository/Url&lt;/td&gt;
&lt;td&gt;RepositoryUrl&lt;/td&gt;
&lt;td&gt;URL where sourcecode is located i.e. &lt;code&gt;https://github.com/NuGet/NuGet.Client.git&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Repository/Type&lt;/td&gt;
&lt;td&gt;RepositoryType&lt;/td&gt;
&lt;td&gt;The repository type i.e. &lt;code&gt;git&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Repository/Branch&lt;/td&gt;
&lt;td&gt;RepositoryBranch&lt;/td&gt;
&lt;td&gt;Optional repository branch info i.e. &lt;code&gt;main&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Repository/Commit&lt;/td&gt;
&lt;td&gt;RepositoryCommit&lt;/td&gt;
&lt;td&gt;Optional commit information i.e. &lt;code&gt;0e4d1b598f350b3dc675018d539114d1328189ef&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Before I explain this, I am getting a bit tired of running &lt;code&gt;dotnet pack&lt;/code&gt; every time. Lucky for me, there is a way to generate a package on build. Update the &lt;code&gt;.csproj&lt;/code&gt; file to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So back to repository info. MSBuild itself is not aware of things like source control. Fortunately, we can pass parameters from the outside to use inside MSBuild. For this, we have the &lt;code&gt;-p&lt;/code&gt; or &lt;code&gt;-property&lt;/code&gt; switch. The following script retrieves the URL, branch name and SHA1 hash from the current commit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;#!/bin/sh -x

REPO_URL=$(git config --get remote.origin.url)
REPO_BRANCH=$(git branch --show-current)
REPO_COMMIT=$(git rev-parse HEAD)
dotnet build -p:RepositoryUrl=&amp;quot;$REPO_URL&amp;quot; -p:RepositoryBranch=&amp;quot;$REPO_BRANCH&amp;quot; -p:RepositoryCommit=&amp;quot;$REPO_COMMIT&amp;quot; -p:RepositoryType=&amp;quot;git&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember, we now generate a package on build. Let us verify we see repo info by opening the created package in NuGet Package Explorer.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/posts/20210327/nuget-metadata/009_npe_repoinfo.png&quot; alt=&quot;Repo Info in Package Explorer&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Even though it is OK to add repo metadata this way, there is a better alternative. This alternative does more than add metadata; it also enables source code debugging from NuGet packages. How cool is that? This technology is called &lt;a href=&quot;https://github.com/dotnet/sourcelink&quot; class=&quot;external&quot;&gt;Source Link&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Like before with the properties, I have no wish to add source link to every package separately. For this, create &lt;code&gt;Directory.Build.targets&lt;/code&gt;, which looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
 &amp;lt;Project&amp;gt;
     &amp;lt;ItemGroup&amp;gt;
         &amp;lt;PackageReference Include=&amp;quot;Microsoft.SourceLink.GitHub&amp;quot; Version=&amp;quot;1.0.0&amp;quot; PrivateAssets=&amp;quot;all&amp;quot; IsImplicitlyDefined=&amp;quot;true&amp;quot; /&amp;gt;
     &amp;lt;/ItemGroup&amp;gt;
 &amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To configure source link, we need to update &lt;code&gt;Directory.Build.props&lt;/code&gt; as well.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Project&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;Authors&amp;gt;Max Hamuly&#225;k&amp;lt;/Authors&amp;gt;
        &amp;lt;Company&amp;gt;Kaylumah&amp;lt;/Company&amp;gt;
        &amp;lt;Description&amp;gt;Logging abstractions for Kaylumah.&amp;lt;/Description&amp;gt;
        &amp;lt;Copyright&amp;gt;Copyright &#169; $(Company) $([System.DateTime]::Now.Year)&amp;lt;/Copyright&amp;gt;
        &amp;lt;PackageTags&amp;gt;logging;abstractions&amp;lt;/PackageTags&amp;gt;
        &amp;lt;PackageIcon&amp;gt;Logo.png&amp;lt;/PackageIcon&amp;gt;
        &amp;lt;PackageLicenseFile&amp;gt;LICENSE&amp;lt;/PackageLicenseFile&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;

    &amp;lt;ItemGroup&amp;gt;
        &amp;lt;None Include=&amp;quot;$(MSBuildThisFileDirectory)Logo.png&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot; /&amp;gt;
        &amp;lt;None Include=&amp;quot;$(MSBuildThisFileDirectory)LICENSE&amp;quot; Pack=&amp;quot;true&amp;quot; PackagePath=&amp;quot;&amp;quot; /&amp;gt;
    &amp;lt;/ItemGroup&amp;gt;

    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;PublishRepositoryUrl&amp;gt;true&amp;lt;/PublishRepositoryUrl&amp;gt;
        &amp;lt;EmbedUntrackedSources&amp;gt;true&amp;lt;/EmbedUntrackedSources&amp;gt;
        &amp;lt;IncludeSymbols&amp;gt;true&amp;lt;/IncludeSymbols&amp;gt;
        &amp;lt;SymbolPackageFormat&amp;gt;snupkg&amp;lt;/SymbolPackageFormat&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To prove that it is still working, here is the entire &lt;code&gt;.nuspec&lt;/code&gt; file after adding Source Link&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;package xmlns=&amp;quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&amp;quot;&amp;gt;
  &amp;lt;metadata&amp;gt;
    &amp;lt;id&amp;gt;Kaylumah.Logging.Extensions.Abstractions&amp;lt;/id&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
    &amp;lt;authors&amp;gt;Max Hamuly&#225;k&amp;lt;/authors&amp;gt;
    &amp;lt;requireLicenseAcceptance&amp;gt;false&amp;lt;/requireLicenseAcceptance&amp;gt;
    &amp;lt;license type=&amp;quot;file&amp;quot;&amp;gt;LICENSE&amp;lt;/license&amp;gt;
    &amp;lt;licenseUrl&amp;gt;https://aka.ms/deprecateLicenseUrl&amp;lt;/licenseUrl&amp;gt;
    &amp;lt;icon&amp;gt;Logo.png&amp;lt;/icon&amp;gt;
    &amp;lt;description&amp;gt;Logging abstractions for Kaylumah.&amp;lt;/description&amp;gt;
    &amp;lt;copyright&amp;gt;Copyright &#169; Kaylumah 2021&amp;lt;/copyright&amp;gt;
    &amp;lt;tags&amp;gt;logging abstractions&amp;lt;/tags&amp;gt;
    &amp;lt;repository type=&amp;quot;git&amp;quot; url=&amp;quot;https://github.com/Kaylumah/NugetMetadataDemo.git&amp;quot; commit=&amp;quot;3378cf33e0061b234c1f58e060489efd81e08586&amp;quot; /&amp;gt;
    &amp;lt;dependencies&amp;gt;
      &amp;lt;group targetFramework=&amp;quot;.NETStandard2.0&amp;quot; /&amp;gt;
    &amp;lt;/dependencies&amp;gt;
  &amp;lt;/metadata&amp;gt;
&amp;lt;/package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;closing-thoughts&quot;&gt;&lt;a href=&quot;#closing-thoughts&quot;&gt;Closing Thoughts&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We looked at setting metadata via MSBuild and sharing metadata between projects. You can take this even further by using MSBuild tasks to verify that packages must have a description like &lt;a href=&quot;https://github.com/dotnet/arcade/blob/9a72efb067b74bb9147f9413ade6173b568ea1af/src/Microsoft.DotNet.Arcade.Sdk/tools/Workarounds.targets#L79&quot; class=&quot;external&quot;&gt;shown here&lt;/a&gt;. It is also possible to create an entire SDK as Microsoft did with &lt;a href=&quot;https://github.com/dotnet/arcade&quot; class=&quot;external&quot;&gt;Arcade&lt;/a&gt;. Of course, Arcade goes much further than just specifying some metadata. You can read about how / why Microsoft did that &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/the-evolving-infrastructure-of-net-core/&quot; class=&quot;external&quot;&gt;on the devblogs&lt;/a&gt;. I experimented with a custom SDK heavily inspired by Arcade, but that is a blog post for another day.&lt;/p&gt;
&lt;p&gt;For now, I hope I was able to teach you something about the power of MSBuild and how we can use it to manipulate our NuGet packages. If you have any questions, feel free to reach out.&lt;/p&gt;
&lt;p&gt;The corresponding source code for this article is on &lt;a href=&quot;https://github.com/Kaylumah/NugetMetadataDemo&quot; class=&quot;external&quot;&gt;GitHub&lt;/a&gt;, there you can see all the changes I addressed in sequence.&lt;/p&gt;
&lt;p&gt;See you next time, stay healthy and happy coding to all &#129528;!&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;sources&quot;&gt;&lt;a href=&quot;#sources&quot;&gt;Sources&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This blog was written based on personal experience when creating packages. If not already explicitly linked in the text, here are some of the primary sources used in the article.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2019&quot; class=&quot;external&quot;&gt;Customize your build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets&quot; class=&quot;external&quot;&gt;MSBuild targets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package-dotnet-cli&quot; class=&quot;external&quot;&gt;Create a package dotnet cli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/quickstart/create-and-publish-a-package-using-the-dotnet-cli&quot; class=&quot;external&quot;&gt;Create and publish a package using dotnet cli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2019&quot; class=&quot;external&quot;&gt;MSBuild reserved and well-known properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cezarypiatek.github.io/post/setting-assembly-and-package-metadata/&quot; class=&quot;external&quot;&gt;Setting assembly and nuget package metadata in .NET Core&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
        </content>
        
        <summary>Discover how to use MSBuild to set your NuGet package&#39;s metadata.</summary>
        
        
        <category term="MSBuild" />
        
        <category term="NuGet" />
        
        
        
            
                
            

            <media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kaylumah.nl/assets/images/posts/20210327/nuget-metadata/cover_image.png" />
            <media:content medium="image" url="https://kaylumah.nl/assets/images/posts/20210327/nuget-metadata/cover_image.png" xmlns:media="http://search.yahoo.com/mrss/" />

        
    </entry>
    
    <entry>
        <id>https://kaylumah.nl/2020/08/01/kaylumah-the-new-home-for-blogs-written-by-max-hamulyak.html</id>
        <title>Guiding my thoughts home</title>
        <author>
            <name>Max Hamulyák</name>
            <email>max@kaylumah.nl</email>
            <uri>https:/kaylumah.nl</uri>
        </author>
        <published>2020-08-01T00:00:00.0000000+00:00</published>
        <updated>2020-08-01T00:00:00.0000000+00:00</updated>
        <link href="https://kaylumah.nl/2020/08/01/kaylumah-the-new-home-for-blogs-written-by-max-hamulyak.html" />
        <content type="html">
            &lt;p&gt;I have decided to pick up blogging again. I wrote a blog post in September 2019 on GitHooks in the past that you can find &lt;a href=&quot;https://medium.com/@kaylumah/using-c-code-in-your-git-hooks-66e507c01a0f&quot; class=&quot;external&quot; :=&quot;&quot;&gt;here&lt;/a&gt;. At the time, I decided to use the platform Medium to voice my thoughts. After I tweeted too &lt;a href=&quot;https://twitter.com/shanselman&quot; class=&quot;external&quot; :=&quot;&quot;&gt;@shanselman&lt;/a&gt; I got way more views on the article then I had expected. So when in 2020, I decided to found Kaylumah, I knew I wanted more than just a regular portfolio website. Since I am learning a lot from my mentor over at ilionx, I want to share lessons learned and start building my brand and identity.&lt;/p&gt;
&lt;h2 id=&quot;so-what-can-you-expect-on-my-blog&quot;&gt;&lt;a href=&quot;#so-what-can-you-expect-on-my-blog&quot;&gt;So what can you expect on my blog&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Not sure about that yet, I suppose we will find out soon enough. The biggest problem will be time, but I will try and share ideas and or projects that I work on professionally, or even experiments I am trying.&lt;/p&gt;
&lt;p&gt;I am a full-stack Software Engineer, and I specialize in backend development (mainly C# / Java). My current front-end framework of choice is Angular, but I have to admit that time, again, is an issue here. Because of time constraints, I cannot dabble in it al much as I would like.
I suspect that I will write articles about my technology stack of choice.
It will also include articles about Azure DevOps and Azure. Such as build pipelines and ARM templates. I might even write more articles about Git and Code quality.&lt;/p&gt;
        </content>
        
        <summary>Moving all content to my own platform</summary>
        
        
        <category term="Announcement" />
        
        
        
            
                
            

            <media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kaylumah.nl/assets/images/posts/20200801/welcome/cover.png" />
            <media:content medium="image" url="https://kaylumah.nl/assets/images/posts/20200801/welcome/cover.png" xmlns:media="http://search.yahoo.com/mrss/" />

        
    </entry>
    
    <entry>
        <id>https://kaylumah.nl/2019/09/07/using-csharp-code-your-git-hooks.html</id>
        <title>Using C# code in your git hooks</title>
        <author>
            <name>Max Hamulyák</name>
            <email>max@kaylumah.nl</email>
            <uri>https:/kaylumah.nl</uri>
        </author>
        <published>2019-09-07T00:00:00.0000000+00:00</published>
        <updated>2021-03-21T00:00:00.0000000+00:00</updated>
        <link href="https://kaylumah.nl/2019/09/07/using-csharp-code-your-git-hooks.html" />
        <content type="html">
            &lt;h2 id=&quot;why-use-hooks&quot;&gt;&lt;a href=&quot;#why-use-hooks&quot;&gt;Why use hooks?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We, as developers, love platforms like GitHub, GitLab, Atlassian, Azure DevOps etc., as our managed git system and collaboration platform. We also love clean code and keep inventing new linters and rules to enforce it. In my opinion, every commit should allow the codebase to deploy to production. There is nothing worse than commits like “fixed style errors” or “fixed build”. These are often small mistakes you want to know as early as possible in your development cycle. You don’t want to break the build for the next developer because he pulled your ‘mistake’ or waste precious build minutes of your CI server. Say you have asked your teammate to review your code; in the meantime, the build server rejects your code. That means you have to go back and fix this, and your teammate has to come back and possibly review again after the changes (i.e., approvals reset on new commit). Doing so would waste a lot of time and effort.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;: I favour server-side hooks, but when using a SaaS solution, this is not always a possibility. I know I would not want someone to run arbitrary code on my servers. Unfortunately, a developer can bypass the client-side hooks. Until we can run, possibly sandboxed, server-side hooks on our prefered platform, we have to make the best of it by using client-side hooks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Githooks are scripts that can execute on certain parts of the git lifecycle. Hooks must be executable, but other than that, hooks&#39; power is only limited to the developer&#39;s imagination. I have seen many samples of hooks written in JavaScript (node) using tools like &lt;a href=&quot;https://github.com/typicode/husky&quot; class=&quot;external&quot;&gt;husky&lt;/a&gt; and &lt;a href=&quot;https://github.com/conventional-changelog/commitlint&quot; class=&quot;external&quot;&gt;commitlint&lt;/a&gt; to enforce a certain way of working. When I was browsing the changes in the upcoming .NET Core 3.0 release, the concept of &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#local-dotnet-tools&quot; class=&quot;external&quot;&gt;local-tools&lt;/a&gt; got me thinking. I knew of the existence of &lt;a href=&quot;https://www.hanselman.com/blog/CAndNETCoreScriptingWithTheDotnetscriptGlobalTool.aspx&quot; class=&quot;external&quot;&gt;dotnet-script&lt;/a&gt;, would that make it possible to C# in my GitHooks?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;: in the past I have used a set-up with node since I occasionally work with front-end frameworks like Angular. Since I had node installed I could use it even in my pure backend projects to enforce commit messages and such. For me it felt dirty, since that would require team members to have node installed. Using the dotnet cli feels less as a forced decision since members are likely to have it installed already.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;lets-get-started&quot;&gt;&lt;a href=&quot;#lets-get-started&quot;&gt;Let’s get started!&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When creating a git repository there is a folder called hooks where all the git hooks are placed. For every event there is a sample post-fixed with .sample that shows the possibility of each hook. This directory is not under source control and we are going to create our own directory to be able to share the hooks with the team.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir git-hooks-example  
cd git-hooks-example  
git init  
dotnet new gitignore  
dotnet new tool-manifest  
dotnet tool install dotnet-script  
dotnet tool install dotnet-format  
mkdir .githooks
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;pre-commit-hook&quot;&gt;&lt;a href=&quot;#pre-commit-hook&quot;&gt;Pre-Commit Hook&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To demonstrate we are going to create a plain hook. To check if it is working &lt;strong&gt;git commit -m “”&lt;/strong&gt; (using empty commit message will abort the commit). You should see the line pre-commit hook printed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#!/usr/bin/env dotnet dotnet-script
Console.WriteLine(&amp;quot;pre-commit hook&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make it executable run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;find .git/hooks -type f -exec rm {} \;
find .githooks -type f -exec chmod +x {} \;
find .githooks -type f -exec ln -sf ../../{} .git/hooks/ \;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we can reference other files (and even load nuget packages) in our csx we will first create a couple of files so we can have code-reuse between the hooks.&lt;/p&gt;
&lt;p&gt;Create a file called &lt;strong&gt;logger.csx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;public class Logger
{
    public static void LogInfo(string message)
    {
        Console.ForegroundColor = ConsoleColor.White;
        Console.Error.WriteLine(message);
    }
    public static void LogError(string message)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.Error.WriteLine(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a file called &lt;strong&gt;command-line.csx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#load &amp;quot;logger.csx&amp;quot;
public class CommandLine
{
    public static string Execute(string command)
    {
        // according to: https://stackoverflow.com/a/15262019/637142
        // thans to this we will pass everything as one command
        command = command.Replace(&amp;quot;\&amp;quot;&amp;quot;, &amp;quot;\&amp;quot;\&amp;quot;&amp;quot;);
        var proc = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = &amp;quot;/bin/bash&amp;quot;,
                Arguments = &amp;quot;-c \&amp;quot;&amp;quot; + command + &amp;quot;\&amp;quot;&amp;quot;,
                UseShellExecute = false,
                RedirectStandardOutput = true,
                CreateNoWindow = true
            }
        };
        proc.Start();
        proc.WaitForExit();
        if (proc.ExitCode != 0)
        {
            Logger.LogError(proc.StandardOutput.ReadToEnd());
            return proc.ExitCode.ToString();
        }
        return proc.StandardOutput.ReadToEnd();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a file called &lt;strong&gt;dotnet-commands.csx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#load &amp;quot;logger.csx&amp;quot;
#load &amp;quot;command-line.csx&amp;quot;
public class DotnetCommands
{
    public static int FormatCode() =&amp;gt; ExecuteCommand(&amp;quot;dotnet format&amp;quot;);
    public static int BuildCode() =&amp;gt; ExecuteCommand(&amp;quot;dotnet build&amp;quot;);

    public static int TestCode() =&amp;gt; ExecuteCommand(&amp;quot;dotnet test&amp;quot;);

    private static int ExecuteCommand(string command)
    {
        string response = CommandLine.Execute(command);
        Int32.TryParse(response, out int exitCode);
        return exitCode;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a file called &lt;strong&gt;git-commands.csx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#load &amp;quot;logger.csx&amp;quot;
#load &amp;quot;command-line.csx&amp;quot;
public class GitCommands
{
    public static void StashChanges()
    {
        CommandLine.Execute(&amp;quot;git stash -q --keep-index&amp;quot;);
    }
    public static void UnstashChanges()
    {
        CommandLine.Execute(&amp;quot;git stash pop -q&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We now have a utility in place for Logging and running GIT and dotnet commands. Next we are going to start with out pre-commit hook. Create a file called &lt;strong&gt;pre-commit&lt;/strong&gt; The difference between this file and the others we just made is that we don’t specify the extension, and that using Shebang we explicitly load dotnet-script. For an explanation of each hook see the article posted below.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/git-hooks&quot; class=&quot;external&quot;&gt;Git Hooks | Atlassian Git Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#!/usr/bin/env dotnet dotnet-script
#load &amp;quot;logger.csx&amp;quot;
#load &amp;quot;git-commands.csx&amp;quot;
#load &amp;quot;dotnet-commands.csx&amp;quot;

// We&#39;ll only runchecks on changes that are a part of this commit so let&#39;s stash others
GitCommands.StashChanges();

int buildCode = DotnetCommands.BuildCode();

// We&#39;re done with checks, we can unstash changes
GitCommands.UnstashChanges();
if (buildCode != 0) {
    Logger.LogError(&amp;quot;Failed to pass the checks&amp;quot;);
    Environment.Exit(-1);
}
// All checks have passed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run &lt;strong&gt;git commit -m “”&lt;/strong&gt; again this time we get an error saying Failed to pass the checks, which makes sense since we don’t have a project yet. We are going to create a simple sln consisting of a classlibary and a test libary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;dotnet new sln  
dotnet new classlib --framework netstandard2.1 --langVersion 8 --name SomeLib --output src/SomeLib  
dotnet new xunit --output tests/SomeLibTests  
dotnet sln add **/*.csproj 
cd tests/SomeLibTests/  
dotnet add reference ../../src/SomeLib/SomeLib.csproj  
cd ../../  
dotnet build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we use git commit -m “” one more time, we get the message about aborting the commit again. We now know that every commit will at least compile :-) If for example we remove the namespace ending curly brace from Class1 we get the error &lt;strong&gt;Class1.cs(7,6): error CS1513: }&lt;/strong&gt;. If we extend our pre-commit hook even further we can have &lt;a href=&quot;https://www.hanselman.com/blog/EditorConfigCodeFormattingFromTheCommandLineWithNETCoresDotnetFormatGlobalTool.aspx&quot; class=&quot;external&quot;&gt;dotnet-format&lt;/a&gt; and dotnet-test running on every commit. If we purposely write a failing test (1 equals 0 or something like that) the build won’t pass.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#!/usr/bin/env dotnet dotnet-script
#load &amp;quot;logger.csx&amp;quot;
#load &amp;quot;git-commands.csx&amp;quot;
#load &amp;quot;dotnet-commands.csx&amp;quot;

Logger.LogInfo(&amp;quot;pre-commit hook&amp;quot;);

// We&#39;ll only runchecks on changes that are a part of this commit so let&#39;s stash others
GitCommands.StashChanges();

int formatCode = DotnetCommands.FormatCode();
int buildCode = DotnetCommands.BuildCode();
int testCode = DotnetCommands.TestCode();

// We&#39;re done with checks, we can unstash changes
GitCommands.UnstashChanges();
int exitCode = formatCode + buildCode + testCode;
if (exitCode != 0) {
    Logger.LogError(&amp;quot;Failed to pass the checks&amp;quot;);
    Environment.Exit(-1);
}
// All checks have passed
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;prepare-commit-message-hook&quot;&gt;&lt;a href=&quot;#prepare-commit-message-hook&quot;&gt;Prepare-commit-message hook&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Thus far, we have not really used anything we need C# for; Admittedly we are using C# to execute shell commands. For our next hook we are going to use System.IO. Imagine as a team you have a commit-message convention. Let&#39;s say you want each commit message to include a reference to your issue tracker.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type(scope?): subject  #scope is optional
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a file &lt;strong&gt;prepare-commit-msg&lt;/strong&gt; in this hook we can provide a convenient commit message place holder if the user did not supply a message. To actual enforce the message, you need the &lt;strong&gt;commit-msg&lt;/strong&gt; hook. In this example, we only create a message for feature branches.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#!/usr/bin/env dotnet dotnet-script
#load &amp;quot;logger.csx&amp;quot;
#load &amp;quot;util.csx&amp;quot;
#load &amp;quot;git-commands.csx&amp;quot;

Logger.LogInfo(&amp;quot;prepare-commit-msg hook&amp;quot;);

string commitMessageFilePath = Util.CommandLineArgument(Args, 0);
string commitType = Util.CommandLineArgument(Args, 1);
string commitHash = Util.CommandLineArgument(Args, 2);

if (commitType.Equals(&amp;quot;message&amp;quot;)) {
    // user supplied a commit message, no need to prefill.
    Logger.LogInfo(&amp;quot;commitType message&amp;quot;);
    Environment.Exit(0);
}

string[] files = GitCommands.ChangedFiles();
for(int i = 0; i &amp;lt; files.Length; i++) {
    // perhaps determine scope based on what was changed.
    Logger.LogInfo(files[i]);
}

string branch = GitCommands.CurrentBranch();
if (branch.StartsWith(&amp;quot;feature&amp;quot;)) {
    string messageToBe = &amp;quot;feat: ISS-XXX&amp;quot;;
    PrepareCommitMessage(commitMessageFilePath, messageToBe);
}

public static void PrepareCommitMessage(string messageFile, string message)
{
     string tempfile = Path.GetTempFileName();
    using (var writer = new StreamWriter(tempfile))
    using (var reader = new StreamReader(messageFile))
    {
        writer.WriteLine(message);
        while (!reader.EndOfStream)
            writer.WriteLine(reader.ReadLine());
    }
    File.Copy(tempfile, messageFile, true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a new helper called &lt;strong&gt;util.csx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;public class Util
{
    public static string CommandLineArgument(IList&amp;lt;string&amp;gt; Args, int position)
    {
        if (Args.Count() &amp;gt;= position + 1)
        {
            return Args[position];
        }
        return string.Empty;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;commit-msg-hook&quot;&gt;&lt;a href=&quot;#commit-msg-hook&quot;&gt;Commit-msg Hook&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The final local git hook I took for a spin is the commit-msg hook. It uses a regex to make sure the commit message is according the specified format.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#!/usr/bin/env dotnet dotnet-script
#load &amp;quot;logger.csx&amp;quot;
#load &amp;quot;util.csx&amp;quot;
#load &amp;quot;git-commands.csx&amp;quot;
using System.Text.RegularExpressions;

Logger.LogInfo(&amp;quot;commit-msg hook&amp;quot;);

string commitMessageFilePath = Util.CommandLineArgument(Args, 0);
string branch = GitCommands.CurrentBranch();
Logger.LogInfo(commitMessageFilePath);
Logger.LogInfo(branch);
string message = GetCommitedMessage(commitMessageFilePath);
Logger.LogInfo(message);

const string regex = @&amp;quot;\b(feat|bug)\b(\({1}\b(core)\b\){1})?(:){1}(\s){1}(ISS-[0-9]{0,3}){1}&amp;quot;;
var match = Regex.Match(message, regex);

if (!match.Success) {
    Logger.LogError(&amp;quot;Message does not match commit format&amp;quot;);
    Environment.Exit(1);
}

public static string GetCommitedMessage(string filePath) {
    return File.ReadAllLines(filePath)[0];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;pre-push-hook&quot;&gt;&lt;a href=&quot;#pre-push-hook&quot;&gt;pre push Hook&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It is even possible to use NuGet packages in our hooks. Let say we want to prevent pushes to master (perhaps not even commits?). We can read a config file using Newtonsoft.Json and look for a protected branch and abort.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-csharp&quot;&gt;#!/usr/bin/env dotnet dotnet-script
#r &amp;quot;nuget: Newtonsoft.Json, 12.0.2&amp;quot;
#load &amp;quot;logger.csx&amp;quot;
#load &amp;quot;config.csx&amp;quot;
#load &amp;quot;git-commands.csx&amp;quot;
using Newtonsoft.Json;

string currentBranch = GitCommands.CurrentBranch().Trim();
Config currentConfig = GetConfig();
bool lockedBranch = currentConfig.ProtectedBranches.Contains(currentBranch);

if (lockedBranch) {
    Logger.LogError($&amp;quot;Trying to commit on protected branch &#39;{currentBranch}&#39;&amp;quot;);
    Environment.Exit(1);
}

public static Config GetConfig()
{
    return JsonConvert.DeserializeObject&amp;lt;Config&amp;gt;(File.ReadAllText(&amp;quot;.githooks/config.json&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;My current hooks are far from the best, and perhaps C# is not the fastest language to use in git hook. I do, however consider the experiment a success. I much rather code in C# than in shell script. Ideas for further improvement include&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;based on the list of changes, determine the scope of the change (i.e. only one directory changed we might know the scope)&lt;/li&gt;
&lt;li&gt;configure the regex, allowed scopes, allowed types&lt;/li&gt;
&lt;li&gt;improve pre-commit-msg for more scenarios&lt;/li&gt;
&lt;li&gt;enforce users to use the hooks&lt;/li&gt;
&lt;li&gt;managing versions of the hooks, on checkout old / different version of pull (with an update of the hooks) sync the directory. &lt;a href=&quot;https://www.viget.com/articles/two-ways-to-share-git-hooks-with-your-team/&quot; class=&quot;external&quot;&gt;(perhaps githook location)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think :-)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/maxhamulyak/git-hooks-example&quot; class=&quot;external&quot;&gt;maxhamulyak/git-hooks-example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Happy Coding &#127867;&lt;/p&gt;
        </content>
        
        <summary>Getting started with C# script in your client-side git hooks</summary>
        
        
        <category term="Git" />
        
        <category term="GitHook" />
        
        <category term="CSharp" />
        
        <category term="Dotnet Core" />
        
        
        
            
                
            

            <media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kaylumah.nl/assets/images/posts/20190907/githooks/cover.png" />
            <media:content medium="image" url="https://kaylumah.nl/assets/images/posts/20190907/githooks/cover.png" xmlns:media="http://search.yahoo.com/mrss/" />

        
    </entry>
    
</feed>